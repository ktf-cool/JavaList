# 任务和线程池

##  一、Callable 与 Future

- `Runnable`封装一个异步运行任务，可以把它想象成一个没有参数和返回值的异步方法。
- `Callable`与`Runnable`类似，但是有返回值。`Callable`接口是一个参数化的类型，只有一个方法`call`.

```
public interface Callable<V>{
	V call() throws Exception;
}
```

> 类型参数是返回值的类型。

- `Future`保存异步计算的结果。

> 可以启动一个计算，将`Future`对象交给某个线程，然后忘掉它。这个`Future`对象的所有者在结果计算好之后就可以获得结果。

- `Future<V>` 接口有下面的方法：

```
V get()
V get(long timeout, TimeUnit unit)
void cancel(boolean mayInterrupt)
boolean isCancelled()
boolean isDone()
```

> 1. 第一个`get`方法的调用会阻塞。
> 2. 第二个`get`方法也会阻塞，如果在计算完成之前调用超时，会抛出一个`TimeoutException`异常。如果运行该计算的线程被中断，这两个方法都将抛出`InterruptedException`。如果计算完成，`get`方法立即返回。
> 3. 如果还在计算，`isDone`方法返回`false`；如果已经完成，则返回`true`。
> 4. 可以用cancel方法取消计算。如果计算还没有开始，它会被取消而且不再开始。如果计算正在执行那么如果`mayInterrupt`参数为`true`，它就会被中断。

- [ ] 取消一个任务的两个步骤：

- 找到并中断底层线程。
- 任务实现（在`call`方法中）必须感知到中断，并放弃它的工作。

> 执行Callable的一种方法是使用`FutureTask`,它实现了`Future` 和 `Runnable`接口，可以构造一个线程来运行这个任务：

```
Callable<Integer> task = ...;
var futureTask = new FutureTask<Integer>(task);
var t = new Thread(futureTask);  //it's a Runnable
t.start();
...
Integer result = task.get();   //it's a Future
```

> 更常见的情况是可以将`Callable`传递到一个执行器。



## 二、执行器

- 执行器（`Executors`)类有许多静态工厂，用来构造线程池。
- 执行者工厂方法：

| 方法                               | 描述                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| `newCachedThreadPool`              | 必要时创建新线程；空线程会保留60秒                           |
| `newFixedThreadPool`               | 池中包含固定数目的线程；空线程会一直保存                     |
| `newWorkStealingPool`              | 一种适合“`fork-json`”任务的线程池，其中复杂的任务会分解为简单的任务，空闲线程会“密取“较简单的任务 |
| `newSingleThreadExecutor`          | 只有一个线程的”池“                                           |
| `newScheduledThreadPool`           | 用于调度执行的固定线程池                                     |
| `newSingleThreadScheduledExecutor` | 用于调度执行的单线程“池”                                     |

> 1. `newCachedThreadPool`方法构造一个线程池，会立即执行各个任务。如果有空闲线程池可用，就是用现有空闲线程执行任务；如果没有可用的空闲线程，则创建一个新线程。
> 2. `newFixedThreadPool`方法构造一个具有固定大小的线程池。如果提交的任务多于空闲线程池数，就把未得到服务的任务放到队列中。当其他任务完成以后再运行这些排队的任务。
> 3. `newSingleThreadExecutor`是一个退化了大小为1的线程池：由一个线程顺序地执行所提交的任务。这3个方法都返回实现了`ExecutorService`接口的`ThreadPoolExecutor`类的对象。

- 如果线程生存期很短，或者大量时间都在阻塞，那么可以使用一个缓存线程池。

> 为了得到最优的运行速度，并发线程数等于处理器内核数。应该使用固定线程池。

- 可用下面的方法之一将`Runnable` 或 `Callable`对象提交给`ExecutorService`:

```
Future<T> submit(Callable<T> task)
Future<?> submit(Runnable task)
Future<T> submit(Runnable task, T result)
```

- 使用线程池做的工作：

1. 调用`Executors`类的静态方法 `newCachedThreadPool` 或 `newFixedThreadPool`。
2. 调用`submit`提交`Runnable` 或 `Callable`对象。
3. 保存好返回的`Future`对象，以便得到结果或者取消任务。
4. 当不想再提交任何任务时，调用`shutdown` 。



## 三、控制任务组

- `invokeAny`方法提交一个`Callable`对象集合中的所有对象，并返回某个已完成任务的结果。（往往是最快的那个）

> 这个方法会阻塞，直到所有任务都完成，并返回表示所有任务答案的一个Future对象列表。得到计算结果后，可以像下面这样对结果进行处理：

```java
List<Callable<T>> tasks = ... ;
List<Future<T>> results = executor.invokeAll(tasks);
for(Future<T> result : results)
	processFurther(result.get());
```

> 在`for`循环中，第一个`result.get()`调用会阻塞，直到第一个结果可用。有必要按计算出结果的顺序得到这些结果。可以利用`ExecutorCompletionService`来管理。



