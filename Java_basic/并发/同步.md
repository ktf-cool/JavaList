# 同步

## 一、竞态条件

- 在大多数的实际的多线程应用中，两个或两个以上的线程需要共享对同一数据的存取，如果两个线程存取同一个对象，并且每个线程分别调用了一个修改该对象状态的方法，会发生什么呢? 

> 两个线程会相互覆盖，取决于线程访问数据的次序可能会导致对象被破坏，这种情况通常被称为**竞态条件**。

- 用一个银行转账案例，随机地选择从哪个原账户转到哪个目标账户，下面的Bank类transfer方法的代码。

```
public void transfer(int from, int to, double amount){
	Syetem.out.print(Thread.currentThread());
	accounts[from] -= amount;
	System.out.printf("%10.2f from %d", amount, from ,to);
	accounts[to] += amount;
	System.out.printf("Total Balance: %10.2f%n", getTotalBalance());
}
```

- 下面是Runnable实例的代码，run方法不断地从一个给定银行账户取钱。每次迭代中，run方法选择一个随机的目标账户和一个随机金额，调用bank对象的transfer方法，让后休眠。

```
Runnable r = () -> {
	try {
		while(true){
			int toAccount = (int) (bank.size() * Math.random());
			double amount = MAX_AMOUNT * Math.random();
			bank.transfer(fromAccount, toAccount, amount);
			Thread.sleep((int) (DELAY * Math.random()));
		}
	} catch (InterruptedException e){
		...
	}
}
```

- 这个程序永远不会结束，每一次交易结束时，transfer方法会重新计算总金额并打印出来。你会发现打印几次之后，账户的总金额发生了改变。

> 当两个线程同时更新一个账户时，就会出现这个问题。

- 假设两个线程同时执行指令 `accounts[to] += amount;`问题在于这不是原子操作，这个指令可能如下处理：

> 1. 将accounts[to]加载到寄存器。
> 2. 增加amount。
> 3. 将结果写回accounts[to]。

- 假定第1个线程执行步骤1和2，然后它的运行权被抢占。再假设第二个线程被唤醒，跟新account数组中的同一个元素。然后第个线程被唤醒并完成其第3步。这个动作会抹去第2个线程所做的跟新，这样一来，总金额就不再正确了。

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE.png)

## 二、锁对象

- Java提供了一个`synchronized`关键字来防止并发访问代码块，另外Java5提供了`ReentrantLock`类。

> `synchronized`关键字会自动提供一个锁以及相关的“条件”，对于大多数需要显示锁的情况，这种机制功能很强大。

- 用`ReentrantLock`保护代码块的基本节后如下:

```
myLock.lock();  // a ReentrantLock object
try{
	critical section
} finally {
	myLock.unlock();  //make sure the lock is unlocked even id an exception is thrown 
}
```

> 这个结构确保任何时刻只有一个线程进入临界区。一旦一个线程锁定了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们会暂停，知道第一个对象释放这个锁对象。

> 注意：要把unlock操作包括在finally子句中，如果临界区的代码抛出一个异常，锁必须释放，否则其他线程将永远阻塞。且使用锁时，不能使用`try - with - resources` 语句。

- 下面使用一个锁对象来保护Bank类的transfer方法：

```
public class Bank{
	private var bankLock = new ReentrantLock();
	...
	public void transfer(int from, int to, double amount){
	bankLock.lock();
	try{
		Syetem.out.print(Thread.currentThread());
        accounts[from] -= amount;
        System.out.printf("%10.2f from %d", amount, from ,to);
        accounts[to] += amount;
        System.out.printf("Total Balance: %10.2f%n", getTotalBalance());
	} finally {
			bankLock.unlock();
		}	
	}
}
```

> 假设一个线程调用了transfer，但是在执行结束前被抢占。再假设第二个线程也调用transfer，由于第二个线程不能获得锁，将在调用lock方法时被阻塞。它会暂停，必须等待第一个线程执行完transfer方法。当第一个线程释放锁，第二个线程才能开始运行。

![image](https://github.com/ktfcool/JavaList/blob/master/images/%E9%9D%9E%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83.png)

> 每个Bank对象都有自己的`ReentrantLock`对象。如果两个线程试图访问同一个Bank对象，那么锁可以用来保证串行化访问。如果两个线程访问不同的Bank对象，每个线程会得到不同的锁对象，两个线程都不会阻塞。因为线程在操作不同的Bank实例时，线程之间不会相互影响。

- 这个称为**重入锁**，因为线程可以反复获得已拥有的锁。锁有一个持有计数来跟踪对lock方法的嵌套调用，线程每一次调用lock后都要调用unlock来释放锁。由于这个特性，被一个锁保护的代码可以调动另一个使用相同锁的方法。

> 要注意保护临界区中的代码不要因为抛出异常而跳出临界区，如果在临界区代码结束之前抛出了异常，finally子句将释放锁，但是对象可能处于被破坏的状态。

## 三、条件对象

- 通常，线程进入临界区后却发现只有满足某个条件之后它才能执行，可以使用一个**条件对象** (也叫做**条件变量**）来管理哪些已经获得一个锁却不能做有用工作的线程。

- 优化银行的模拟程序，如果一个账户没有足够的资金转账，我们不希望从这样的账户转出资金。注意不能使用类似下面的代码：

```
if(bandk.getBalance(from)>=amount)
	bank.transfer(from, to, amount)
```

> 在成功的通过这个测试之后，但是在调用transfer方法之前，当前线程有可能被中断。在线程再次运行前，账户余额可能已经低于提款金额，必须确保在检查余额与转账活动之间没有其他线程修改余额，可以使用一个锁来测试和转账操作：

```
public void transfer(int from, int to, int amount){
	bankLock.lock();
	try{
		while(accounts[from]<amount){
			//wait
			...
		}
		//transfer funds
		...
	}
	finally{
		bankLock.unlock();
	}
}
```

> 账户中没有足够资金时，要等待直到另一个线程向账户中增加了资金，但是这个线程刚刚获得了对bankLock的排他性访问权，因此别的线程没有存款的机会，这里就要引入条件对象。

- 一个锁对象可以有一个或多个相关联的条件对象，你可以用`newCondition`方法获得一个条件对象。

```
class Bank{
	private Condition sufficientFunds;
	...
	public Bank(){
		...
		sufficientFunds = bankLock.newCondition();
	}
}
```

> 如果transfer方法发现资金不足，它会调用`sufficientFunds.await();`当前线程暂停，并放弃锁，这就允许另一个线程执行，增加余额。

- 等待获得锁的线程和已经调用了`wait`方法的线程存在本质上的不同。一旦一个线程调用了await方法，它就会进入这个条件的等待集。当锁可用时，该线程并不会变为可运行状态，仍处于非活动状态，直到另一个线程在同一条件上调用`signalAll`方法。

- 当另一个线程完成转账时，它应该调用 `sufficientFunds.signalAll();`这个调用会重新激活等待这个条件的所有线程。当这些线程从等待集中移除时，它们再次成为可运行的线程，调度器最终将再次将它们激活。同时它们会尝试重新进入该对象，一旦锁可用，它们中的某个线程将从await调用返回，得到这个锁，**并从之前暂停的地方继续执行。**

> 此时，线程应该再次测试条件，不能保证现在一定满足条件 ——`signalAll`方法仅仅是通知等待的线程：现在有可能满足条件，需要再次检查条件。

- 通常，await调用应该放在如下的循环中

```
while(!(OK to proceed)){
	condition.await();
}
```

- 当一个线程调用await时，它就没有办法重新自行激活，需要其他某个线程调用`signalAll`方法，如果没有其他线程来重新激活等待的线程，它就永远不会再运行了，导致**死锁**现象。

> 如果所有的其他线程都被阻塞，最后一个线程调用了await方法但是没有解除另外某个线程的阻塞，现在这个线程也会阻塞，没有线程解除其他线程的阻塞状态，程序会永远挂起。

- 应该什么时候调用`signalAll`？只要一个对象状态有改变，而且可能有利于等待的线程，就可以调用`signalAll`。

> 注意：`signalAll`调用不会立即激活一个等待的线程，他只是解除等待线程的阻塞，使这些线程可以在当前线程释放锁之后竞争访问对象。另一个signal方法只是随机选择等待集中的一个线程，并解除这个线程的阻塞状态，这比解除所有线程的阻塞更高效，但也存在危险。

- 只有当线程拥有一个条件的锁时，它才能在这个条件上调用await、`signlAll`或signal方法。



## 四、synchronized关键字

- 锁用来保护代码片段，一次只能有一个线程执行被保护的代码。
- 锁可以管理试图进入被保护代码段的线程。
- 一个锁可以有一个或多个相关联的条件对象。
- 每个条件对象管理那些已经进入被保护代码段但还不能运行的线程。
- 从1.0版开始，Java中的每个对象都有一个内部锁，如果一个方法声明时有synchronized关键字，那么对象的锁将保护整个方法。要调用这个方法，线程必须获得内部对象锁。

```
public synchronized void method(){
	method body
}
```

等价于

```
public void method(){
	this.intrinsicLock.lock();
	try{
		method body
	}finally{
		this.intrinsiacLock.unlock();
	}
}
```

> 内部对象锁只有一个关联条件，wait方法将一个线程增加到等待集中，`notifyAll/notify`方法可以解除等待线程的阻塞。调用`wait`或`notifyAll`等价于：

```
intrinsicCondition.await();
intrinsicCondition.signalAll();
```

> `wait、notify、notifyAll`方法是`Object`类的`final`方法。`Condition`方法必须命名为`await`、`signalAll`和`signal`，从而不会与那些方法产生冲突。

- [ ] 内部锁和条件存在一些限制

- 不能中断一个正在尝试获得锁的线程。
- 每个所仅有一个条件可能是不够的。
- 不能指定尝试获得锁时的超时时间。

- [ ] 使用Lock和Condition对象还是同步方法

- 最好既不使用`Lock/Condition`也不使用`synchronized`关键字。可以使用`java.util.concurrent`包中的某种机制，它会为你处理所有的锁定。
- 如果`synchronized`关键字适合你的程序，那么尽量使用这种做法，这样可以减少编写的代码量和出错的概率。
- 如果特别需要`Lock/Condition`结构提供的额外能力，则使用`Lock/Condition`。



## 五、同步块

- 每一个Java对象都有一个锁，线程可以通过调用同步方法获得锁，还可以进入一个**同步块**获得锁。

```
synchronized(obj){   //this is the syntax for a synchronized block
	critical section
}
```

- 有时程序员使用一个对象的锁来实现额外的原子操作，被称为**客户端锁定**

> Java虚拟机对同步方法提供了内置支持，不过，同步块会编译为很长的字节码序列来管理内部锁。

## 六、监视器概念

- [ ] 监视器有如下特征：

- 监视器是只包含私有字段的类。
-  监视器类的每个对象有一个关联的锁。
- 所有方法由这个锁锁定。
- 锁可以有任意多个相关联的条件。

- [ ] Java对象不同于监视器的方面：削弱了线程的安全性

- 字段不要求是private。
- 方法不要求是synchronized。
- 内部锁对客户是可用的。

## 七、volatile字段

- 有多处理器的计算机能够暂时在寄存器或本地内存缓存中保存内存值。其结果是，运行在不同处理器上的线程可能看到同一个内存位置有不同的值。
- 编译器可以改变指令执行的顺序以使吞吐量最大化，编译器不会选择可能改变代码语义的顺序，但是编译器有一个假定，认为内存值只在代码中有显式的修改指令时才会改变。然而，内存值有可能被另一个线程改变。
- volatile关键字为实例字段的同步访问提供了一种免锁机制。

> 如果声明一个字段为volatile,那么编译器和虚拟机就知道该字段可能被另一个线程并发跟新。

- 假设一个对象有一个boolean标记done,它的值有一个线程设置，而由另一个线程查询，可以使用锁：

```
private boolean done;
public synchronized boolean isDone(){return done;}
public synchronized void setDone(){done = true;}
```

> 使用内部对象锁不是一个好主意，如果另一个线程已经对该对象加锁，`isDone`和`setDone`方法可能会阻塞。可以只为这个变量使用一个单独的锁，但是会很麻烦。

- 在这种情况下，将字段声明为`volatile`就很合适

```
private volatile boolean done;
public boolean isDone(){return done;}
public void setDone(){done = true;}
```

> 编译器会插入适当的代码，以确保如果一个线程对done变量做了修改 ，这个修改对读取这个变量的所有其他线程都可见。

- volatile变量不能提供原子性，例如方法：

```
public void flipDone() {
	done = !done;    //not atomic
}
```

> 不能确保翻转字段中的值，不能保证读取、翻转和写入不被中断。

## 八、final变量

- 除了使用锁或volatile修饰符从多个线程安全的读取一个字段，还可以将这个字段声明为final：

```
final var accounts = new HashMap<String,Double>();
```

> 其他线程会在构造器完成构造之后才看到这个accounts变量，如果不使用`final`，就不能保证其他线程看到的是accounts跟新后的值，它们可能都只是看到null,而不是新构造的`HashMap`。这个映射的操作并不是线程安全的，如果有多个线程更改和读取这个映射，仍然需要同步。

## 九、原子性

- `java.util.concurrent.atomic`包中有很多类使用了高效的机器级指令（而没有使用锁）来保证其他操作的原子性。
- 例如：`AtomicInteger`类提供了方法`incrementAndGet`和`decrementAndGet`,它们将以原子方式将一个整数进行自增或自减。例如可以安全地生成一个数值序列，如下所示:

```
public static AtomicLong nextNumber = new AtomicLong();
// in some thread...
long id = nextNumber.incrementAndGet();
```

> `incrementAndGet`方法以原子方式将`AtomicLong`自增。也就是说：获得值、增1并设置然后生成新值的操作不会中断，可以保证即使是多个线程并发地访问同一个实例，也会计算并返回正确的值。

- 有很多方法可以以原子方式设置增减值，如果希望完成更复杂的跟新，就必须使用`compareAndSet`方法。假设希望跟踪不同线程观察最大值，下面代码不可行：

```
public static AtomicLong largest = new AtomicLong();
// in some thread
largest.set(Math.max(largest.get(),observed));  //error--race condition
```

> 这个跟新不是原子的。实际上，可以提供一个lambda表达式更新变量：

```
largest.updateAndGet(x -> Math.max(x, observed));
或
largest.accumulateAndGet(observed,Math::max);
```

- 如果有大量线程要访问相同的原子值，性能会大幅度下降，因为乐观更新需要太多次重试。`LongAdder`和`LongAccumulator`类解决了这个问题。

> `LongAdder`包括多个变量（加数），其总和为当前值，可以有多个线程跟新不同的加数，线程个数增加会自动提供新的加数，通常情况下，只有当所有工作都完成之后才需要总和的值，对于这种情况，这种方法会很高效。

- `LongAccumulator`将这种思维添加到任意的累加操作。在构造器中，可以提供这个操作以及它的零元素，要加入新的值，可以调用accumulate。调用get来获得当前值。下面的代码可以与`LongAdder`同样的效果：

```
var adder = new LongAccumulator(Long::sum,0);
// in some thread...
adder.accumulate(value);
```



## 十、死锁

- 锁和条件不能解决多线程中可能出现的所有问题。考虑下面的问题：

1. 账户1：$200
2. 账户2：$300
3. 线程1：从账户1转$300到账户2
4. 线程2：从账户2转$400带账户1

如图：

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E6%AD%BB%E9%94%81%E6%83%85%E5%86%B5.png)

> 线程1和线程2都被阻塞。因为账户1以及2中的余额都不足以进行转账，两个线程都无法执行下去。

- 有可能会因为每一个线程要等待更多的钱款存入而导致所以线程都被阻塞，这样的状态称为**死锁**。

- 还有一种账户会导致死锁，让第i个线程负责向第i个账户存钱，而不是从第i个账户取钱。这样一来。可能所有的线程都集中到一个账户上，每个线程都试图从这个账户上取出大于该账户余额的钱。在`SynchBankTest`程序中，调用`TransferRunnable`类的run方法，在`transfer`调用中，交换`fromAccount`和`toAccount`。运行该程序几乎会立刻死锁。

- 还有一种很容易导致死锁的情况：在`SynchBankTest`程序中，将`signalAll`方法修改为signal方法，会发现该程序最终会挂起。`signalAll`方法会通知所有等待增加资金的线程，signal方法只解除一个线程的阻塞，如果该线程不能继续运行，所有的线程都会阻塞。

## 十一、线程局部变量

- 有时可能要避免共享变量，使用`ThreadLocal`辅助类为各个线程提供各自的实例。
- 例如：`SimpleDateFormat`类不是线程安全的。假设有一个静态变量：

```
public static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
```

> 如果两个线程都执行以下操作：

```
String dateStemp = dateFormat.format(new Date());
```

> 结果可能很混乱，因为`dateFormat`使用的内部数据结构可能会被并发的访问所破坏。当然可以使用同步，但是开销很大；或者也可以在需要时构造一个局部`SimpleDateFormat`对象，不过这太浪费了。

- 要为每个线程构造一个实例，可以使用以下代码：

```
public static final ThreadLocal<SimpleDateFormat> dateFormat
	= ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
```

- 要访问具体的格式化方法，可以调用：

```
String dateStamp = dateFormat.get().format(new Date());
```

> 在一个线程中首次调用get时，会调用构造器中的lambda表达式。get方法会返回属于当前线程的那个实例。



## 十二、为什么废弃stop和suspend方法

- 最初的Java版本定义了一个`stop`方法来终止一个线程，以及一个`suspend`方法来阻塞一个线程直至另一个线程调用`resume`。`stop`和`suspend`方法有一些共同点：都试图控制一个给定线程的行为，而没有线程的互操作。

> stop、suspend、resume方法已经被废弃。stop方法天生就不安全，经验证明suspend方法经常会导致死锁。

- `stop`方法会终止所有的未结束的方法，包括`run`方法。当线程被终止，它会立即释放被它锁定的所有对象的锁，这回导致对象处于不一致的状态。

> 当一个线程要终止另一个线程时，它无法知道什么时候调用stop方法是安全的，而什么时候会导致对象被破坏。希望停止一个线程的时候应该中断该线程，被中断的线程可以在安全的时候终止。

- `suspend`不会破坏对象，但是如果用suspend挂起一个持有锁的线程，那么在线程回复运行之前这个锁是不可用的。如果调用suspend方法的线程试图获得同一个锁，那么程序死锁：被挂起的线程等着被恢复，而将其挂起的线程等待获得锁。
