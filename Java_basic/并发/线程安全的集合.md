# 线程安全的集合

## 一、阻塞队列

- 使用队列，可以安全地从一个线程向另一个线程传递数据。

> 线程安全的队列类的实现者必须考虑锁和条件。

- 试图向队列添加元素而队列已满时，或者是想从队列移出元素而队列为空的时候,**阻塞队列**将导致线程阻塞。

> 在协调多个线程之间的合作时，工作线程可以周期性的将中间结果存储在阻塞队列中，其他工作线程移除中间结果，并进一步进行修改。

- 队列会自动地平衡负载。

> 如果第一组线程运行的比第二组线程慢，第二组在等待结果时将会阻塞。如果第一组线程运行的更快，队列会填满，直到第二组赶上来。

- 阻塞队列方法

| 方法    | 正常动作               | 特殊情况下的动作                               |
| ------- | ---------------------- | ---------------------------------------------- |
| add     | 添加一个元素           | 如果队列满，则抛出`IllegalStateException`异常  |
| element | 返回队头元素           | 如果队列空，则抛出`NoSuchElementException`异常 |
| offer   | 添加一个元素并返回true | 如果队列满，则返回false                        |
| peek    | 返回队头元素           | 如果队列空，则返回null                         |
| poll    | 移除并返回队头元素     | 如果队列空，则返回null                         |
| put     | 添加一个元素           | 如果队列满，则阻塞                             |
| remove  | 移除并返回队头元素     | 如果队列空，则抛出`NoSuchElementException`异常 |
| take    | 移除并返回队头元素     | 如果队列空，则阻塞                             |

> 1. 如果使用队列作为线程管理工具，将要用到`put`和`take`方法。
> 2. 当试图向满队列添加元素或者想从空队列得到对头元素时，`add`、`remove` 和 `element`操作会抛出异常。
> 3. 在一个多线程程序中，队列可能会在任何时候变空或变满，应当使用`offer`、`poll` 和 `peek`方法作为替代。

- `poll`  和 `peek`方法返回`null`来指示失败，因此，向这些队列中插入`null`值是非法的。
- 带有超时时间的`offer`方法和 `poll` 方法。例如下面的调用：

```
boolean success = q.offer(x, 100, TimeUnit.MILLISECONDS);
```

> 尝试在100毫秒的时间内在队尾插入一个元素。如果成功则返回`true`，如果超时则返回`false`。

- 下面的调用：

```
Object head = q.poll(100,TimeUnit.MILLISECONDS);
```

> 尝试在100毫秒的时间内移除队头元素，如果成功返回队头元素，如果超时返回null。

- 如果队列满，put方法阻塞，如果队列空，take方法阻塞。它们与不带超时参数的offer和poll方法等效。

- `java.util.concurrent`包提供了阻塞队列的几个变体。

> 1. `LinkedBlockingQueue`的容量没有上界，也可以选择指定一个最大容量。
> 2. `LinkedBlockingDeque`是一个双端队列。
> 3. `ArrayBlockingQueue`在构造参数时需要指定容量，并且有一个可选的参数来指定是否需要公平性。若设置了公平参数，那么等待了最长时间的的线程会优先得到处理。
> 4. `PriorityBlockingQueue`是一个优先队列，而不是先进先出队列。元素按照它们的优先级顺序移除，这个队列没有上限，但是如果队列是空的，获取元素的操作会阻塞。



## 二、高效的映射、集和队列

- `java.util.concurrent`包提供了映射、有序集和队列的高效实现：`ConcurrentHashMap`、`ConcurrentSkipListMap`、`ConcurrentSkipListSet`和`ConcurrentLinkedQueue`。

> 这些集合使用复杂的算法，通过允许并发的访问数据结构的不同部分尽可能减少竞争。

- 与大多数集合不同，这些类的`size`方法不一定在常量时间内完成操作，确定这些集合的当前大小需要遍历。

- 集合返回**弱一致性**的迭代器。

> 这意味着迭代器不一定能反映出它们构造之后的所有更改，不会将同一个值返回两次，也不会抛出`ConcurrentModificationException`异常。

- `java.util`包中的集合，如果集合在迭代器构造之后发生改变，集合的迭代器将会抛出一个`ConcurrentModificationException`异常。

- 并发散列映射默认可以有至多16个同时运行的书写器线程。

> 可以有更多的书写器线程，但是同一时间如果多于16个，其他线程将暂时阻塞。



## 三、映射条目的原子更新

- `ConcurrentHashMap`原来的版本只有为数不多的方法可以实现原子更新。

- 假设我们希望统计观察到某些特征的频度，作一个简单的例子，假设多个线程会遇到单词，我们想统计它们的频率。

> 可以使用`ConcurrentHash<String, Long>`，考虑计数自增的代码。显然下面的代码不是线程安全的：

```java
Long oldValue = map.get(word);
Long newValue = oldValue == null ? 1 : oldValue + 1;
map.put(word, newValue);  //error -- might not replace oldValue
```

> 可能会有另一个线程在同时更新同一个计数。

- 为什么原本线程安全的数据结构会允许非线程安全的操作。

> 1. 如果多个线程修改一个普通的`HashMap`，可能会破坏内部结构（一个链表数组）。有些连接可能丢失，或者甚至构成循环，使得这个数据结构不再可用。
> 2. 对于`ConcurrentHashMap`不会发生这种情况。get 和 put 代码不会破坏数据结构，但由于操作序列不是原子的，所以结果不可预知。

- 老版本的Java中，必须使用replace操作，它会以原子方式用一个新值替换原值。前提是之前没有其他线程把原值替换为其他值。必须一直这么做，直到替换成功：

```
do{
	oldValue = map.get(word);
	newValue = oldValue == null ? 1 : oldValue + 1;
} while(!map.replace(word, oldValue, newValue));
```

- 可以使用一个`ConcurrentHashMap<String, AtomicLong>`,以及以下更新代码：

```
map.putIfAbsent(word, new AtomicLong());
map.get(word).incrementAndGet();
```

> 这回为每个自增构造一个新的`AtomicLong`,而不管是否需要。

- `Java API` 提供了一些新方法，调用compute方法时可以提供一个键和一个计算新值的函数。这个函数接收键和相关联的值（如果没有值，则为null），它会计算新值。

> `ConcurrentHashMap`中不允许有`null`值。很多方法都使用`null`值来指示映射中某个给定的键不存在。



## 四、对并发散列映射的批操作

- `JavaAPI` 为并发散列映射提供了批操作，即使有其他线程在处理映射，这些操作也能安全执行。

> 批操作会遍历映射，处理遍历过程中找到的元素，这里不会冻结映射的当前快照。除非你恰好知道批操作运行时映射不会被修改，否则就要把结果看成是映射状态的一个近似。

- [ ] 有3种不同的操作：

- `search` 为每个键或值应用一个函数，直到函数生成一个非 `null` 的结果，然后搜索终止，返回这个函数的结果。
- `reduce`（归约）组合所有的键或值，这里要使用所提供的一个累加函数。
- `forEach` 为所有键或值应用一个函数。

- [ ] 每个操作都有4个版本：

- `operationKeys`: 处理键。
- `operationValues`: 处理值。
- `operation`: 处理键和值。
- `operationEntries`: 处理 `Map.Entry` 对象。

> 对于上述各个操作，需要指定一个**参数化阀值**。如果映射包含的元素多于这个阀值，就会并行完成批操作。

- 如果希望批操作在一个线程中运行，可以使用阀值 `Long.MAX_VALUE`。如果希望用尽可能多的线程运行批操作，可以使用阀值1 。

- search方法的版本：

```java
U searchKeys(long threshold, BiFunction<? super K, ? extends U>f)
U searchValues(long threshold, BiFunction<? super V, ? extends U> f)
U search(long threshold, BiFunction<? super K,? super V, ? extends U> f)
U searchEntries(long threshold, BiFunction<Map.Entry<K,V>, ? extends U> f)
```

> 假设找出第一个出现次数超过1000次的单词，需要搜索键和值：

```
String result = map.search(threshold, (k,v) -> v > 1000 ? K : null);
```

> result会设置为第一个匹配的单词，或者如果搜索函数对所有输入都返回null，则返回null。

- [ ] `forEach`方法有两种形式。

- 第一种形式只对各个映射条目应用一个**消费者函数**，例如:

```
map.forEach(threshold, (k,v) -> System.out.println(k + " -> " + v));
```

- 第二种形式还有一个额外的**转换器**函数作为参数，要先应用这个函数，其结果会传递到消费者：

```java
map.forEach(threshold, (k,v) -> k + "->" + v,     //transformer
	System.out::println);   //consumer
```

> 转化器可以用作一个过滤器。只要转换器返回null，这个值就会被跳过。



## 五、并发集视图

- 假设你想要的是一个很大的线程安全的集而不是映射。并没有`ConcurrentHashSet`类，也不想自己创建，可以使用包含“假”值的`ConcurrentHashMap`,不过这回得到一个映射而不是集，当然不能应用Set接口的操作。

> 静态`newKeySet`方法会生成一个`Set<K>`, 这实际上是`ConcurrentHashMap<k, Boolean>`的一个包装器。（所有映射值都为`Boolean.TRUE`)

```
Set<String> words = ConcurrentHashMap.<String>newKeySet();
```

> 如果原来有一个映射，`keySet`方法可以生成这个映射的键集。可以从这个集中删除元素，但是从这个集中添加元素没有意义，没有相应的值可以增加。

- `ConcurrentHashMap`方法还有第二个`keySet`方法，它包含一个默认值，为集增加元素时可以使用这个方法。

```
Set<String> words = map.keySet(1L);
words.add("Java");
```

> 如果“Java"不存在，现在它就会有一个值1。



## 六、写数组的拷贝

- `CopyOnWriteArrayList`和`CopyOnWriteArraySet`是线程安全的集合，其中所有更改器会建立底层数组的一个副本。如果迭代器访问集合的线程数超过更改集合的线程数，这样很有用。

- 当构造一个迭代器的时候它包含当前数组的一个引用，如果这个数组后来被更改了，迭代器仍旧使用旧数组，但是集合的数组已经替换。因此原来的迭代器可以访问一致的视图，而且不存在任何同步开销。



## 七、并行数组算法

- Arrays提供了大量的并行化操作。静态`Arrays.paralleSort`方法可以对一个基本类型值或对象的数组排序，例如：

```java
var contents = new String(File.readAllBytes(
	Path.of("alice.txt")),StandardCharsets.UTF_8);   // read file into string
Stringp[] words = contents.split("[\\P{L}]+");  //split along nonletters
Arrays.paralleSort(words);
```

> 对对象排序时，可以提供一个Comparator。

```
Arrays.paralleSort(words, Comparator.comparing(String::length));
```

> 对所有方法都可以提供一个范围的边界

```
values.paralleSort(values.length / 2, values.length);  //sort the upper half
```

- `parallelSetAll` 方法会用由一个函数计算得到的值填充一个数组。这个函数接收元素索引，然后计算相应位置上面的值。

```
Arrays.parallelSetAll(Values, i -> i % 10);
	// file values with 0 1 2 3 4 5 6 7 8 9 0 1 2
```

- `parallelPrefix`方法，会用一个给定结合操作的响应前缀的累加结果替换各个数组元素



## 八、较早的线程安全集合

- Java的初始版本开始，`Vector` 和 `Hashtable`类就提供了动态数组和散列表的线程安全的实现。

> 现在这些类被认为已经过时，而被`ArrayList` 和 `HashMap` 类所取代。不过那些类不是线程安全的。

- 任何集合类都可以通过使用**同步包装器**变成线程安全的：

```java
List<E> synchArrayList = Collections.synchronizedList(new ArrayList<E>());
Map<K,V> synchHashMap = Collections.synchronizedMap(new HashMap<K,V>());
```

> 结果集合的方法使用锁加以保护，可以提供线程安全的访问。

- 应该确保没有任何线程通过原始的非同步方法访问数据结构。

> 要确保这一点，最容易的方法是确定不保存原始对象的任何引用，简单地构造一个集合并立即传递包装器。

- 如果客户端迭代访问一个集合，同时另一个线程仍有机会更改这个集合，那么仍然需要使用"客户端"锁定：

```java
synchronized(synchHashMap){
	Iterator<K> iter = synchHashMap.keySet().iterator();
	while(iter.hasNext())...;
}
```

> 如果使用“for each” 循环，必须使用同样的代码。因为循环使用了一个迭代器。在迭代过程中，如果另一个线程更改了集合，迭代器会失效，抛出`ConcurrentModificationException`异常。

- 最好使用`java.util.concurrent`包中定义的集合。而不是同步包装器。