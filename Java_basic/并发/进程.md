# 进程

## 一、建立一个进程

- 首先指定你想要执行的命令。可以提供一个`List<String>`, 或者直接提供命令字符串。

```
var builder = new ProcessBuilder("gcc","myapp.c");
```

> 第一个字符串必须是一个可执行的命令，而不是一个shell内置命令。

- 每个进程都有一个工作目录，用来解析相对目录名。

> 默认情况下，进程的工作目录与虚拟机相同，通常是启动`java`程序的那个目录。可以用`directory`方法改变工作目录：

```java
builder = builder.directory(path.toFile());
```

> 配置`ProcessBuilder`的各个方法都返回其自身，所以可以把命令串起来，最终会调用：

```
Process p = new ProcessBuilder(command).directory...start();
```

- 要指定如何处理进程的标准输入、输出和错误流。默认情况下他们分别是一个管道，可以用以下方法访问：

```
OutputStream processIn = p.getOutputStream();
InputStream processOut = p.getInputStream();
InputStream processErr = p.getErrorStream();
```

> 进程的输入流是`JVM`的一个输出流。我们会写入这个流，而我们写的内容会变成进程的输入。我们会读取进程写入输出和错误流的内容，对我们来说，它们都是输入流。

- 可以指定新进程的输入、输出和错误流与`JVM`相同。

> 如果用户在一个控制台运行`JVM`，所有用户输入都会转发到进程而进程的输出将显示在控制台上。可以调用：

```java
builder.redirectIO()
```

> 为这3个流建立这个设置。如果你只想继承某些流。可以把值:

```
ProcessBuilder.Redirect.INHERIT
```

> 传入 `redirecInput`、`redirecOutput` 或 `redirecError`方法，例如：

```
builder.redirecOutPut(ProcessBuild.Redirect.INHERIT);
```

> 通过提供File对象，可以将进程流重定向到文件：

```
builder.redirectInput(inputFile)
	.redirectOutput(outputFile)
	.redirecError(errorFile)
```

> 进程启动时，会创建或删除输出和错误文件。要追加到现有文件可以使用：

```
builder.redirecOutput(ProcessBuilder.Redirect.appendTo(outputFile));
```

> 合并输出和错误流通常很有用，这样就能按进程生成这些消息的顺序显示输出和错误消息。可以调用：

```
builder.redirecErrorStream(true)
```

> 启用合并，如果这样做，就不能再在`ProcessBuilder`上调用`redirecError`,也不能在`Process`上调用`getErrorStream`.



## 二、运行一个进程

- 配置了构建器之后，要调用它的`start`方法启动进程。

> 如果把输入、输出和错误流配置为管道，现在可以写输入流，并读取输出和错误流。例如：

```java
Process process = new ProcessBuilder("/bin/ls", "-l")
	.directory(Path.of("/tmp").toFile())
	.start();
try (var in = new Scanner(process.getInputStream())){
	while (in.hasNextLine())
		System.out.println(in.nextLine());
}
```

> 进程流的缓冲空间是有限的。不能写入太多输入，而且要及时读取输出。如果有大量输入和输出，可能需要在单独的线程中产生和消费这些输入输出。

- 要等待进程完成，可以调用：

```
int result = process.waitFor();
```

- 不想无期限的等待，可以这样做：

```
long delay = ... ;
if(process.waitfor(delay, TimeUnit.SECONDS)){
	int result = process.exitValue;
	...
}else{
	process.destroyForcibly();
}
```

> 第一个`waitFor`调用返回过程的退出值（按惯例，0表示成功，或者返回一个非0的错误码）。如果进程没有超时，第二个调用返回true。然后需要调用`exitValue`方法获取退出值。

- 你可能并不会等待进程结束，而只是让它继续运行，不时调用`isAlive`来查看进程是否仍存活。要杀死这个进程，可以调用`destory`或`destroyForcibly`。（这两个调用之间的区别取决于平台）

- 最后会在进程完成时接收到一个异步通知。调用`process.onExit()`会得到一个`CompletableFuture<Process>`,可以用来调度任何动作。

```
process.onExit().thenAccept(
	p -> System.out.println("Exit value:" + p.exitValue())
);
```



## 三、进程句柄

- 要获得程序启动的一个进程的更多信息，或者想更多地了解你的计算机上正在运行的任何其他进程，可以使用`ProcessHandle`接口。可以用4种不同的方式得到一个`ProcessHandle`:

1. 给定一个`Process`对象`p`，`p.toHandle()`会生成它的`ProcessHandle`。
2. 给定一个long类型的操作系统进程ID，`ProcessHandle.of(id)`可以生成这个进程的句柄。
3. `Process.current()`是运行这个Java虚拟机的进程的句柄。
4. `ProcessHandle.allProcesses()` 可以生成对当前进程可见的所有操作系统进程的`Stream<ProcessHandle>`。

- 给定一个进程句柄，可以得到它的进程ID、父进程、子进程和后代进程：

```
long pid = handle.pid();
Optional<ProcessHandle> parent = handle.parent();
Stream<ProcessHandle> chileren = handle.children();
Stream<ProcessHandle> descendants = handle.descendants();
```

> `allProcesses`、`children`和`descendants`方法返回的`Stream<ProcessHandle>`实例只是当时的快照。

- `info`方法可以生成一个`ProcessHandle.Info`对象，他提供了一些方法来获得进程的有关信息

```
Optional<String[]> arguments()
Optional<String> command()
Optional<String> commandLine()
Optional<String> startInstant()
Optional<String> totalCpuDuration()
Optional<String> user()
```

> 所有这些方法都返回`Option`值，因为可能某个特定的操作系统不能报告这个信息。要监视或强制进程终止，与`Process`类一样，`ProcessHandle`接口也有`isAlive`、`supportsNormalTermination`、`destroy`、`destroyForcibly`和`onExit`方法。不过没有对应的`waitFor`方法。

