# 内部类

## 一、使用内部类访问对象状态
- 1.概念：**内部类**是定义在另一个类中的类。 
> 使用内部类的原因：
     1. 内部类可以对一个包中的其他类隐藏。
     2. 内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据。

- 2.看下面一段代码：
~~~
public class TalkingClock {
    
    private int interval;
    private boolean beep;
    
    public TalkingClock(int interval, boolean beep){...}
    public void start() { ... }
    
    public class  TimePrinter implements ActionListener{               //an inner class ， 也可以将内部类声明为私有的，只有外部类方法才能构造内部类对象。
        public void actionPerformed(ActionEvent event){
            System.out.println("At the tone, the time is " +
                    Instant.ofEpochMilli(event.getWhen()));
            if (**beep**) Toolkit.getDefaultToolkit().beep();           //   beep = outer.beep   outer 不是java关键字，只是说明内部类的有关机制 。
        }
    }
}
~~~

图解：


  TimePrinter 对象是由 TalkingClock  类的方法构造的 。可以看到，一个内部类方法可以访问自身的数据字段，也可以访问创建它的外围类对象的数据字段。
为此，内部类对象有一个隐式引用，指向创建它的外部类对象。编译器会为内部类添加一个无参数构造器。

## 二、内部类的特殊语法规则
 - 上面代码中的if 语句条件可以这样写：`TalkingClock.this.beep`  ,  OuterClass.this 表示外围类引用 。
> 编写内部类对象的构造器： `outerObject.new InnerClass(construction paramenters)`
在外围的作用域之外，引用内部类：`OuterClass.InnerClass` 。

- **注意**：
1.内部类中声明的所有静态字段必须是final，并初始化为一个编译常量。 且内部类不能有 static 方法。
2.编译器会把内部类转换为常规的类文件，并用 $ 分隔外部类名与内部类名。

## 三、局部内部类
- 1.概念：定义在一个方法中的类成为局部内部类。
- 2.注意：局部内部类不能有访问说明符。（ public 、 private）局部内部类的作用域被限定在声明这个局部内部类的块中。除了此方法之外，任何方法都不能访问此类。
                 局部内部类还能访问外部类的字段和局部变量。

## 四、匿名内部类
- 1.概念：只要创建这个类的对象，不需要指定名字的类成为匿名内部类。
- 2.语法：
```
new SuperType(construction parameters)
      {
           inner class method and data
      }
```

- SuperType 可以为接口， 内部类就需要实现这个接口。且不能有任何构造参数 ，但是 （ ）还是要提供。
- SuperType 可以是一个类， 内部类就需要扩展这个类。
- 匿名内部类没有类名，所以不能有构造方法，构造参数要传递给**超类**构造器 。尽管没有构造器，但是可以提供一个对象初始化代码块。例如：

~~~
var count = new Person("Dracula")
        {
              { 初始化代码块 }    
  }
~~~

## 五、静态内部类
- 1.概念：当内部类不需要有外围类对象的一个引用，可以将内部类声明为static，就不会生成那个引用， 该类叫做静态内部类。
- 2.注释：
 
    >  1.只要内部类不需要访问外围类对象，就应该使用静态内部类。可以用嵌套类表示静态内部类。
        2.与常规类不同，静态内部类可以有静态字段和方法。
        3.在接口中声明的内部类自动是static 和 public 。
