# 接口

## 1.概念:
>用来描述类应该做什么，而不指定它们具体如何做。

**定义格式:**
```
public interface Comparable{
     int compareTo(Object other);
}
```
**注意：**
- 1.接口中的所有方法都自动是public方法，在接口中声明方法时，不需要提供public 。
- 2.接口没有实例字段，接口也没有实例，可以将接口看成是没有实例字段的抽象类（区别稍后介绍）。
- 3.使用接口，需要让一个类来实现那个接口。实现接口时必须把方法声明为public 。

**步骤：**
- 1.让类声明为实现给定的接口，使用关键字 **implements**: ```class Employee implements Comparable``` 。
* 2.对接口中所有方法实现定义。

## 2.属性
- 1.接口不是类，不能使用new实体化一个接口，但是能声明接口的变量，且接口变量必须引用实现了这个接口的类对象。
- 2.可以使用 **instanceof** 检查一个对象是否实现了某个特定的接口。
- 3.接口中的字段总是   ```public static final ```。（建议不要提供多余的关键字）
- 4.接口可以多实现：中间用**逗号**隔开 ；  ```class Employee implement Cloneable, Comparable``` 。

## 3.接口与抽象类的区别
- 抽象类只能扩展一个类，而每个类可以实现多个接口，同时还能继承其他类。
 ```
class Employee extands Person, Comparable   //error
class Employee extands Person, implements Comparable    //OK
 ```

## 4.接口中的方法
 - **1.静态和私有方法** ：
> 在java8中允许在接口中增加静态方法，通常将静态方法放在伴随类中。
> 在java9中，接口中的方法允许是私有方法。只能作为其他方法的辅助方法。
 - **2.默认方法** ：
- 可以为接口方法提供一个默认实现，必须使用default修饰符标记这样一个方法。
 ```
public interface Comparable<T> {
          default int comparaTo(T other) {
                  retuen 0;
         }
}
 ```
> 这并没有太多的用处，因为每个接口的具体实现都会覆盖这个方法 。在某些情况下可能会很有用。

  **解决默认方法的冲突** ：
 **问题**：现在一个接口中将一个方法定义为默认方法，又在父类或另一个接口中定义同样的方法，会发生什么情况？
 - 1.父类优先。如果父类提供了一个具体方法，同名且参数类型相同的默认方法会被忽略。
 - 2.接口冲突。如果两个接口有相同的默认方法，那么实现类必须覆盖这个方法来结局冲突。
 - 3.接口与类冲突。如果继承的接口和实现的类有相同的方法，那么采用“**类优先**”规则。即类中的方法生效。
