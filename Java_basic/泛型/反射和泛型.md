# 反射和泛型

## 一、泛型class类

- class类是泛型的。例如：`String.class`是一个`Class<String>`类的对象。（且是唯一的对象）

> 类型参数允许Class<T> 方法返回类型更加具有特定性，Class<T> 的以下方法就使用了类型参数：

```java
T newInstance()
T cast(Object obj)
T[] getEnumConstants()
...
```

> 1. newInstance方法返回这个类的一个实例，有无参构造器获得。
> 2. 如果给定的对象是T的一个子类型，cast方法就会返回这个给定对象。
> 3. 如果这个类不是enum类或T类型枚举值的数组getEnumConstants将返回null。

## 二、使用Class <T> 参数进行类型匹配

- 匹配泛型方法中Class<T> 参数的类型变量有时会很有用，例如：

```java
public static <T> Pair<T> makPair(Class<T> c) throws Exception{
	return new Pair<>(c.newInstance(), c.newInstance())
}
```

> 如果调用 `makPair(Employee.class) , Employee.class`将是一个Class<Employee>类型的对象，makPair方法的类型参数T同Employee匹配，编译器可以推断出该方法返回一个Pair<Employee>  。

## 三、虚拟机中的泛型类型信息

- [ ] Java泛型的突出特性之一是在虚拟机中擦除泛型类型，但是擦除的类仍然保留原先的微弱记忆。例如：原始的Pair类知道它源于泛型类Pair<T>。例如：`public static <T extends Comparable<? super T>> T min(T[ ] a)`擦除之后的方法：`public static Comparable  min( Comparable  [ ] a)` 。可以使用反射API来确定：

- 这个泛型方法有一个名为T的类型参数。
- 这个类型参数有一个子类型限定，其自身又是一个泛型类型。
- 这个限定类型有一个通配符参数。
- 这个通配符参数有一个超类型限定。
- 这个泛型方法有一个泛型数组参数。

