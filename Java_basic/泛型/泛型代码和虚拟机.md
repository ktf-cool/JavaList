# 泛型代码和虚拟机

## 一、类型擦除

- 无论何时定义一个泛型类型，都会自动提供一个相应的**原始类型**，就是去掉类型参数后的泛型类型名泛型变量会被**擦除**，并替换为其限定类型。
- Pair<T>的原始类型如下：(看上片文章Pair的泛型类型)

```java
public class Pair {    
    
    private Object first;
    private Object second;   

    public Pair() { first=null;second=null; }

    public Pair(Object first, Object second) { this.first = first;this.second = second; }

    public Object getFirst() {return first; }    

    public Object getSecond() { return second;}

    public void setFirst(Object newValue){ first = newValue; }  
   
    public void setSecond(Object newVlue){ second = newVlue; }
   
}
```

- 如果 `Pair<T extends Comparable & Serializable> implements Serializable{... }`

则在Pair的原始类型中 T 都换为 **Comparable** ，如果 Serializable在Comparable 前面，则T换为Serializable。

## 二、转换泛型表达式

- 编写一个泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换，例如：

```java
Pair<Employee> buddies = ... ;
Employee buddy = buddies.getFirst();
```

> getFirst擦除后的返回类型应该是 Object 类型，编译器会自动强转为 Employee 类型。当访问一个泛型字段时也会插入强制类型转换。

## 三、转换泛型方法

- 看下面这个代码：

```java
class DateInterval extends Pair<LocalDate> {
	public void setSecond(LocalDate second){
		...
	}
}
```

- 这个类擦除后：

```java
class DateInterval extends Pair {
	public void setSecond(LocalDate second){
		...
	}
}
```

- 在一节中我们知道另一个从Pair继承的Setsecond方法：

```java
public void setSecond(Object second)
```

- 两个方法有不同的类型参数，考虑下面的语句：

```java
var interval = new DateInterval(...);
Pair<LocalDate> pair = interval;
pair.setSecond(aDate);
```

> 这里会调用 DateInterval.setSecond,但是希望setSecond具有多态性，调用最适合的那个方法。类型擦除与多态发生了冲突，于是编译器在DateInterval类中生成了一个**桥方法**。

```java
public void setSecond(Object second){ setSecond((LocalDate) second);}
```

> 桥方法不仅用于泛型类型，

- 总之，记住以下几个事实：

1. 虚拟机中没有泛型，只有普通的类和方法。
2. 所有的参数类型都会替换为它们的限定类型。
3. 会形成桥方法来保持多态
4. 为保持类型安全性，必要时插入强制类型转换。
