# 泛型限制与局限性

## 一、不能用基本类型实例化类型参数

- 没有 Pair<double>,只有 Pair<Double>,其原因就在于类型擦除，擦除后Pair类含有Object类型的字段，而Object类型不能存储double值。

## 二、运行时类型查询只适用于原始类型

- 虚拟机中的对象总有一个特定的非泛型类型，因此，所有的泛型只产生原始类型。

例如：

```java
if(a instanceof Pair<String> )  //error
```

如果仅是测试任意类型的一个Pair:

```java
if(a instanceof Pair<T> )  //error
```

或者强制类型转换：

```java
Pair<String> p = (Pair<String>) a;  //warning
```

- 如果查询一个对象是否属于某个泛型时，你会得到一个编译器错误（使用instanceof时）或警告（使用强制类型转换时）。
- getClass方法总是返回原始类型，如：

```java
Pair<String> stringPair = ...;
Pair<Employee> employeePair = ...;
if(stringPair.getClass == employeePair.getClass)  //they are equel
```

> 比较结果是true，两次getClass调用都返回Pair.class。

## 三、不能创建参数化类型的数组

- 不能实例化参数类型的数组。例如：

```java
var table = new Pair<String>[10];  //error
```

> 擦除之后，table的类型是Pair[],可以转换为 Object[]; Object objarray = table;  数组会记住元素类型，如果存储其他类型的元素，会抛出一个异常。

```java
objarray[0] = "hello";  //error
```

- 对于泛型，擦除会使这种机制无效，如下：

```java
objarray[0] = new Pair<Employee>() ;
```

> 尽管能够通过数组存储的检查，但仍会导致一个类型的错误。所以不允许创建参数化类型的数组，但是声明类型为 Pair<String<[ ] 的变量仍是合法的，不过不能初始化。

- 可以声明通配类型的数组，然后进行强制类型转换；

```java
var table = (Pair<String>[]) new Pair<?>[10];
```

> 结果将是线程不安全的。如果需要收集参数化类型对象，简单的使用`ArrayList:ArrayLsit<Pair<String>>`更安全有效。



## 四、不能实例化类型变量

- 不能再在类似 new T(...) 的表达式中使用类型变量，例如：

```java
public Pair() { first = new T(); second = new T() ;}  //error
```

> 类型擦除T变成Object，而不希望调用 `new Object();` 解决办法：让调用者提供一个构造器表达式。例如：

```java
Pair<String> p = Pair.makePair(String::new);
```

