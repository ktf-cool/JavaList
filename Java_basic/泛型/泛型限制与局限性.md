# 泛型限制与局限性

## 一、不能用基本类型实例化类型参数

- 没有 Pair<double>,只有 Pair<Double>,其原因就在于类型擦除，擦除后Pair类含有Object类型的字段，而Object类型不能存储double值。

## 二、运行时类型查询只适用于原始类型

- 虚拟机中的对象总有一个特定的非泛型类型，因此，所有的泛型只产生原始类型。

例如：

```java
if(a instanceof Pair<String> )  //error
```

如果仅是测试任意类型的一个Pair:

```java
if(a instanceof Pair<T> )  //error
```

或者强制类型转换：

```java
Pair<String> p = (Pair<String>) a;  //warning
```

- 如果查询一个对象是否属于某个泛型时，你会得到一个编译器错误（使用instanceof时）或警告（使用强制类型转换时）。
- getClass方法总是返回原始类型，如：

```java
Pair<String> stringPair = ...;
Pair<Employee> employeePair = ...;
if(stringPair.getClass == employeePair.getClass)  //they are equel
```

> 比较结果是true，两次getClass调用都返回Pair.class。

## 三、不能创建参数化类型的数组

- 不能实例化参数类型的数组。例如：

```java
var table = new Pair<String>[10];  //error
```

> 擦除之后，table的类型是Pair[],可以转换为 Object[]; Object objarray = table;  数组会记住元素类型，如果存储其他类型的元素，会抛出一个异常。

```java
objarray[0] = "hello";  //error
```

- 对于泛型，擦除会使这种机制无效，如下：

```java
objarray[0] = new Pair<Employee>() ;
```

> 尽管能够通过数组存储的检查，但仍会导致一个类型的错误。所以不允许创建参数化类型的数组，但是声明类型为 Pair<String<[ ] 的变量仍是合法的，不过不能初始化。

- 可以声明通配类型的数组，然后进行强制类型转换；

```java
var table = (Pair<String>[]) new Pair<?>[10];
```

> 结果将是线程不安全的。如果需要收集参数化类型对象，简单的使用`ArrayList:ArrayLsit<Pair<String>>`更安全有效。



## 四、不能实例化类型变量

- 不能再在类似 new T(...) 的表达式中使用类型变量，例如：

```java
public Pair() { first = new T(); second = new T() ;}  //error
```

> 类型擦除T变成Object，而不希望调用 `new Object();` 解决办法：让调用者提供一个构造器表达式。例如：

```java
Pair<String> p = Pair.makePair(String::new);
```
> makePair方法接收一个Supplier<T>, 这是一个函数式接口，表示一个无参数且返回类型为T的函数。

```java
public static <T> Pair<T> makePair(Supplier<T> constr){
	return new Pair<>(constr.get(), constr.get());
}
```

- 传统解决方法是通过反射调用 `Constructor().newInstance` 方法来构造泛型对象。

## 五、不能构造泛型数组

- 就像不能实例化泛型实例一样，也不能实例化数组。数组本身带有类型，用来监控虚拟机中的数组存储，这个类型会被擦除，如下：

```java
public static<T extends Comparable> T[] minmax(T...a){
	T[] mm = new T[2];  //error
}
```

> 这个方法总是构造Comparable[2]数组。如果数组作为一个类的私有实例字段，可以将数组的类型声明为擦除类型并使用强制类型转换，例如ArrayList类的实现。但是对于本例，mainmax方法返回一个T[ ]数组，类型不对运行时就会得到错误结果，

```java
public static<T extends Comparable> T[] minmax(T...a){
	var result = new Comparable[2];  //error
    ...
   return (T[]) result; 
}
```

> 以下调用 `String[ ] names = ArrayAlg.minmax("Tom","Dicj", "Harry");`  ,编译时不会有任何警告，方法返回后 `Comparable[ ]`引用强制类型转换为 `String[ ]` 时,将会抛出一个异常。 这种情况下，提供一个数组构造器表达式：`String[ ] names = ArrayAlg.minmax(String[ ]::new, "Tom","Dicj", "Harry"); String[ ]::new`指示一个函数，给定所需的长度，会构造一个指定长度的String数组，minmax方法使用这个参数生成一个有正确类型的数组。

```java
public static<T extends Comparable> T[] minmax(IntFunction<T[]> constr, T...a){
	T[] result = constr.apply(2); //error
    ...
}
```

## 六、泛型类的静态上下文中类型变量无效

- 不能在静态字段或方法中引用类型变量。例如：

```java
public class Singleton<T> {
	private static T singleInstance;  //error
	private static T getSingleInstance(){        //error
		if(singleInstance = null)
			return singleInstance；
	}  
}
```

> 这样是行不通的，类型擦除之后，只剩下Singleton类，只包含一个`singleInstance`字段，因此禁止使用带有类型变量的静态字段个方法。

## 七、不能抛出或捕获泛型类的实例

- 泛型类扩展Throwable是不合法的。例如：以下定义就不能正常编译：

```java
public class Problem<T> extends Exception{/*...*/ } //error，can't extend Throwable;
```

- catch 子句中不能使用类型变量，例如。以下方法将不能通过编译：

```java
public static <T extends Throwable> void doWork(Class<T> t){
	try{
		do work
	} catch(T e) {      //error-can't catch type variable 
		Logger.gloabl.info(...);
	}           
	
}
```

- 在异常规范中使用类型变量是允许的。以下方法是合法的：

```java
public static <T extends Throwable> void d {
	{
		do work
	} 
	catch(Throwable realCause){
		t.initCause(realCause);
		throw t;
	}
}
```

## 八、可以取消对检查型异常的检查

- Java异常处理的基本原则是，必须为所有的检查型异常提供一个处理器，可以利用泛型取消这个机制：

```java
@SuppressWarnings("unchecked")
static <T extends Throwable> void throwAs(Throwable t) throw T {
	throw (T) t ;
}
```

> 假设这个方法包含在接口Task中，如果有一个检查型异常 e, 并调用 Task.<RuntimeException>throwAs(e);
>
> 编译器就会认为e 是一个非检查型异常，一下代码会把所有异常都转换为编译器所认为的非检查型异常：

```java
try {
	do work
} catch (Throwable t){
	Task.<RuntimeException>throwAs(t);
}
```

> 这可以解决Runnable 接口中的run方法抛出异常的问题，run方法不可以抛出检查型异常，我们可以提供一个从Task到Runnable的适配器，它的run方法可以抛出任何异常。

