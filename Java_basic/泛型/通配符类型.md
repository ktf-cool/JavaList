# 通配符类型

## 一、通配符概念

- 在通配符中允许参数发生变化，如下：

```java
Pair<? extends Employee>
```

> 表示任何泛型Pair类型，它的类型参数是Employee的子类，如Pair<Manager>但不是Pair<String>。

- 看下面这段代码：

```java
public static void printBuddies(Pair<Employee> p){
	Employee first = p.getFirst();
	Employee second = p.getSecond();
	System.out.println(first.getName() + "and" + second.getName() + "are buddies.");
}
```

> 不能将Pair传递给这个方法，但是可以使用通配符类型：

```java
public static void printBuddies(Pair<? extends Employee>)
```

> Pair<Manager>是`Pair<? extends Employee>`的子类型，而且不会破坏Pair<Manager>。



## 二、通配符的超类型限定

- 通配符限定可以指定一个超类型限定：`？ supper Manager`

> 这个通配符限定为Manager的所有超类型。可以为方法提供参数，但不能使用返回值。

- 看下面这个例子：

```java
public static void minmaxBonus(Maneger[] a, Pair<? super Manager> result){
	if (a.length == 0 ) return;
	Manager min = a[0];
	Manager max = a[0];
	for(int i = 1; i < a.length; i++){
		if(min.getBonus() > a[i].getBonus()) min = a[i];
		if(max.getBomus() < a[i].getBonus()) max = a[i];
	}
	result.setFirst(min);
	result.setSecond(max);
}
```

> 这个方法接受任何的Pair, 带有超类限定类型的通配符允许你写入一个泛型对象，而带有子类限定的通配符允许你读取一个泛型对象。

- 以下是超类型限定类的另一种引用，Comparable接口本身就是一个泛型类：

```java
public interface Comparable<T> {
	public int compareTO(T other);
}
```

> 这里类型变量指示了other参数的类型，在接口是泛型接口之前，other是一个object，这个方法的实现中必须有一个强制类型转换。由于Comparable是一个泛型类型，如果计算String 数组的最小值，T就是类型String，而String是`Comparable<String>`的一个子类型，但处理一个LocalDate对象的数组时，LocalDate实现了ChronoLocalDate,而ChronoLocalDate扩展了 Comparable<ChronoLocalDate>，因此LocalDate实现了 Comparable<ChronoLocalDate>，而不是 Comparable<LocalDate>。这种情况下可以可以用超类型来解决：

```java
public static <T extends Comparable<? super T>> T min(T[ ] a)...
    
int compareTo(? super T)
```

## 三、无限定通配符

- 可以使用无限定的通配符，例如：Pair<?>。Pair<?> 与Pair 的本质区别是：可以用任意的Object的对象调用原始Pair类的setFirst方法。

> 它对于很多简单的操作非常有用，例如：下面这个方法用来测试一个对组是否包含一个null引用，不需要实际类型。

```java
public static boolean hasNulls(Pair<?> p){
	return p.getFirst() == null || p.getSecond() == null;
}
```

> 通过将hasNull转换成泛型方法，可以避免使用通配符类型;但是带有通配符的可读性更好。

```java
public static <T> boolean hasNulls(Pair<T> p)
```

## 四、通配符捕获

- 通配符不是类型变量，不能在编写代码中使用  "?" 作为一种类型。下面的代码是非法的：

```java
public static void swap(Pair<?> p){
	? t = p.getFirst();  //error
	p.setFirst(p.getSecond);
	p.setSecond(t);
}
```

> 我们可以使用一个辅助方法swapHelper,如下：

```java
public static <T> void swapHelper(Pair<T> p){
	T t = p.getFirst();
	p.setFirst(p.getSecond);
	p.setSecond(t);
}
```

> swapHelper是一个泛型方法，而swap不是，有一个固定的类型参数Pair<T>。可以使用swap调用swapHelper，这样swapHelper方法的参数T捕获通配符。通配符只有在非常限定的情况下才是合法的，编译器必须能够确保通配符表示单个的通配类型。例如 ，ArrayList<Pair<T>>中的T永远不能捕获ArrayList<Pair<?>>中的通配符，因为此时的？不是单个的通配符类型。

