#  内存映射文件





## 一、内存映射文件的性能

- 文件操作处理时间的数据：

| 方法           | 时间  |
| -------------- | ----- |
| 普通输入流     | 110秒 |
| 带缓冲的输入流 | 9.9秒 |
| 随机访问文件   | 162秒 |
| 内存映射文件   | 7.2秒 |

> 如表所示：内存映射比使用带缓冲的顺序输入要快一点，但是比使用`RandomAccessFile`快很多。

- 精确的值因机器不同会产生很大差异，但与随机访问相比，性能提供总是很显著。对于中等尺寸文件的顺序读入则没有必要使用内存映射。
- `java.nio`包使内存映射变的十分简单，像下面这样：

1. 从文件中获得一个通道，通道是用于磁盘文件的一种抽象，使我们可以访问注入内存映射、文件加锁机制以及中间快速数据传递等操作系统特性。

```
FileChannel channel = FileChannel.open(path, options);
```

2. 通过调用`FileChannel`类的map方法从这个通道中获得一个`ByteBuffer`。可以指定想要映射的文件区域与映射模式，支持的模式有三种：

- `FileChannel.MapMode.READ_ONLY`:所产生的缓冲区是只读的，任何对该缓冲区写入的尝试都会导致`ReadOnlyBufferException`异常。

- `FileChannel.MapMode.READ_WRITE`:所产生的缓冲区是可写的，任何修改都会在某个时刻写回到文件中。注意：其他映射同一个文件的程序可能不能立即看到这些修改，多个程序同时进行文件映射的确切行为是依赖操作系统的。

- `FileChannel.MapMode.PRIVATE`:所产生的缓冲区的可写的，但是任何修改对这个缓冲区来说都是私有的，不会传播到文件中。

> 一旦有了缓冲区，就可以使用`ByteBuffer`类和`Buffer`超类的方法读写数据了。

- 缓冲区支持顺序和随机数据访问，它有一个可以通过`get`和`put`操作来移动的位置，如，可以像下面这样顺序遍历缓冲区中的所有字节：

```java
while(buffer.hasRemaining()) {
	byte b = buffer.get();
    ...
}
```

或者像下面这样进行随机访问：

```java
for(int i = 0; i < buffer.limit(); i++) {
	byte b = buffer.get(i);
	...
}
```

- 可以用下面的方法读写字节数组：

```java
get(byte[] bytes)
get(byte[], int offset, int length) 
```

- 还有下面的方法：

```java
getInt           getChar
getLong          getFloat
getShort         getDouble
```

> 用来读入在文件中存储为二进制值的基本类型值。

- 要想缓冲区写数字，可以使用下列方法：

```
putInt         putChar
putLong        putFloat
putShort       putDouble
```

> 在恰当的时机，以及当通道关闭时，会将这些修改写回到文件中。



## 二、缓冲区数据结构

- 缓冲区是由具有相同类型的数值构成的数组，Buffer类是一个抽象类，有众多的子类，包括 `ByteBuffer`、`CharBuffer`、`DoubleBuffer`、`IntBuffer`、`LongBuffer` 和 `ShortBuffer`。

> `StringBuffer`类与这些缓冲区没有关系。

- 在实践中，最常用的是将`ByteBuffer`和`CharBuffer`。每个缓冲区都具有：
  - 一个容量，它永远不能改变。
  - 一个读写位置，下一个值将在此进行读写。
  - 一个界限，超过它进行读写时没有意义的。
  - 一个可选的标记，用于重复一个读入或写出操作。

这些值满足下面的条件：

​														0 ≤ 标记 ≤ 读写位置 ≤ 界限 ≤ 容量

- 使用缓冲区的目的是执行 “写， 然后读入“ 循环。假设我们有一个缓冲区，在一开始，它的位置为0，界限等于容量，我们不断地调用`put`将值添加到这个缓冲区中，当我们耗尽所有的数据或者写出的数据量达到容量大小时，就该切换带读入操作了。

 ![](D:\java笔记\Java脑图\一个缓冲区.png)

- 这是调用flip方法将界限设置到当前位置，并把位置复位到0.现在在remaining方法返回正数时（它返回的值是界限-位置），不断的调用get。在我们将缓冲区中所有的值都读入之后，调用clear是缓冲区为下一次写循环做好准备。clear方法将位置复位到0，并将界限复位到容量。
- 如果重读缓冲区，可以使用rewind或mark/reset方法。
- 要获取缓冲区，可以调用诸如`ByteBuffer.allocate`或`ByteBuffer.wrap`这样的静态方法。
- 可以用来自某个通道的数据填充缓冲区，或者将缓冲区的内容写出到通道中。

```java
ByteBuffer buffer = ByteBuffer.allocate(RECORD_SIZE);
channel.read(buffer);
channel.position(newpos);
buffer.flip();
channel.write(buffer);
```

> 可以替代随机访问文件。