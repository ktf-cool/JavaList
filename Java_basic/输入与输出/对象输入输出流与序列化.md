# 对象输入\输出流与序列化



## 一、保存和加载序列化对象

- 为了保存对象数据，需要打开一个`ObjectOutputStream`对象：

```java
var out = new ObjectOutputStream(new FileOutputStream("employee.dat"));
```

- 为了保存对象，可以直接使用`ObjectOutputStream`的`writeObject`方法：

```java
var harry = new Employee("Harry Hacker", 50000, 1989, 10, 1);
var boss = new Manage("Carl Cracker", 80000, 1987, 12, 15);

out.writeObject(harry);
out.writeObject(boss);
```

- 为了将这些对象读回，需要获得一个`ObjectInputStream`对象：

```java
var in = new ObjectInputStream(new FileInputStream("employee.dat"));
```

- 用`readObject`方法以这些对象被写出时的顺序获得它们：

```java
var e1 = (Employee) in.writeObject();
var e2 = (Employee) in.readObject();
```

> 对希望在对象输出流中存储或从对象输入流中恢复的所有类都应进行一下修改。这个类必须实现`Serializable`接口：

```java
class Employee implements Serializable
```

> `Serializable`接口没有任何方法，因此你不需要对这些类做任何改动。
>
> 只有在写出对象时才用`writeObject `\ `readObject`方法，对于基本类型你需要使用`writeInt` \ `readInt`这样的方法。

- 在幕后，是`ObjectOutputStream`在浏览对象的所有域，并存储它们的内容。

- 当一个对象被多个对象共享时，作为它们各自状态的一部分，会发生什么呢？

- 对Mange类稍微做些修改，假设每个经理都有一个秘书：

```java
class Manager extends Employee {
	private Employee secretary;
	...
}
```

- 可以两个经理共用一个秘书：

```java
var harry = new Employee("Harry Hacker", ...);
var carl = new Manager("Carl Cracker", ...);
carl.setSecretary(harry);
var tony = new Manager("Tony Tester", ...);
tony.setSecretary(harry);
```

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E4%B8%A4%E4%B8%AA%E7%BB%8F%E7%90%86%E5%8F%AF%E4%BB%A5%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E5%85%B1%E6%9C%89%E7%9A%84%E9%9B%87%E5%91%98.png)

> 不能去保存和恢复秘书对象的内存地址，因为当对象被重新加载时，它可能占据的是与原来完全不同的内存地址。每个对象都是用一个序列号来保存的，下面是其算法：

- 对你遇到的每一个对象引用都关联一个序列号。
- 对于每个对象，当一次遇到时，保存其对象数据到输出流中。
- 如果某个对象之前已经被保存过，那么只写出与之前保存过的序列号为x的对象相同。

> 读回对象时，整个过程是反过来的。

- 对于对象输入流中的对象，在第一次遇到其序列号时，构建它，并使用流中数据来初始化它，然后记录这个顺序号和新对象之间的关联。
- 当遇到“与之前保存过的序列号为x的对象相同” 这一标记时，获取与这个序列号相关联的对象引用。



## 二、修改默认的序列化机制

- 某些数据是不可以序列化的。

> 例如：只有本地方法有意义的存储文件句柄或窗口句柄的整数值，这种信心在稍后重新加载对象或将其传送到其他机器上时都是没有用处的。事实上，这种域的值如果不恰当，还会引起本地方法崩溃。

- `Java`拥有一种很简单的机制来防止这种域被序列化，那就是将它们标记成`transient`的。如果这些域属于不可序列化的类，你也需要将它们标记成`transient`的。瞬时的域在对象被序列化时总是被跳过的。

- 序列化机制为单个的类提供了一种方式，去向默认的读写行为添加验证或任何其他想要的行为，可序列化的类可以定义具有下列签名的方法：

```java
private void readObject(ObjectInputStream in)
	throws IOException, ClassNotFoundException;
private void writeObject(ObjectOutputStream out)
	throws IOException;
```

> 之后数据域就再也不会被序列化，而是调用这些方法。

- 除了让序列化机制来保存和恢复对象数据，类还可以定义他自己的机制，这个类必须实现`Externalizable`接口，这需要它定义两个方法：

```java
public void readExternal(ObjectInputStream in)
	throws IOExcetion, ClassNotFoundExcetion;
public void writeExternal(ObjectOutputStream out)
	throws IOException;
```

> 这些方法对包括超类数据在内的整个对象的存储和恢复负全责。在写出对象时，序列化机制在输出流中仅仅只是记录该对象所属的类。在读入可外部化的类时，对象输入流将用无参构造器创建一个对象，然后调用`readExternal`方法，下面展示了如何为Employee类实现这些方法：

```java
public void readExternal(ObjectInput s) throws IOException {
	name = s.readUTF();
	salary = s.readDouble();
	hireDay = LocalDate.ofEpochDay(s.readLong());
}

public void writeExternal(ObjectOutput s) throws IOExcetion {
	s.writeUTF(name);
	s.writeDouble(salary);
	s.writeLong(hireDay.toEpochDay());
}
```



## 三、为克隆使用序列化

- 序列化机制提供了一种克隆对象的简便途径，只要对应的类是可序列化的即可。
- 直接将对象序列化到输出流中，然后将其读回，这样产生的新对象是对现有对象的一个深拷贝。再此过程中不必将对象写出到文件中，可以用`ByteArrayOutputStream`将数据保存到字节数组中。

- 要想得到clone方法，只需扩展`SeriaCloneable`类。
