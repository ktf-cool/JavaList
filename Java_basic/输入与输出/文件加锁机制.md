# 文件加锁机制

- 当多个同时执行的程序需要修改同一个文件的情形，这些程序需要进行通信，不然这个文件很容易被破坏。文件锁可以解决这个问题，它可以控制对文件或文件中某个范围的字节的访问。
- 假设你的引用程序将用户的偏好存储在一个配置文件中，当用户调用这个应用的两个实例时，这两个实例就有可能同时会写配置文件。
  - 这种情况下，第一个实例应该锁定文件，当第二个实例发现文件被锁定时，它必须决策是等待直至文件解锁，还是直接跳过这个写操作过程。
- 要锁定一个文件，可以调用`FileChannel`类的`lock`或`tryLock`方法：

```java
FileChannel = FileChannel.open(path);
FileLock lock = channel.lock();
```

或

```java
FileLock lock = channel.tryLock();
```

> 第一个调用会阻塞直至可获得锁，而第二个调用将立即返回，要么返回锁，要么在锁不可获得的情况下返回`null`。这个文件将保持锁定状态，直至通道关闭，或者在锁上调用了`release`方法。

- 可以通过下面的调用锁定文件的一部分：

```java
FileLock lock(long start, long size, boolean shared);
```

或

```java
FileLock tryLock(long start, long size, boolean shared)
```

> 如果`shared`标志为`false`，则锁定文件的目的是读写；而如果为true，则这是一个共享锁，允许多个线程从文件中读入，并阻止任何线程获得独占的锁。

- 调用`FileLock`类的 `isShared`方法可以查询所持有的锁的类型。

- 要确保在操作完成时释放锁，最好在一个带资源的`try`语句中执行释放锁的操作：

```java
try (FileLock lock = channel.lock()) {
	access the locked file or segment
}
```

- 文件加锁机制是依赖于操作系统的，注意以下几点：
  - 在某些系统中文件加锁的建议性的，如果一个应用未能得到锁，它仍然可以向被另一个应用并发锁定的文件执行写操作。
  - 在某些系统中，不能在锁定一个文件的同时将其映射到内存中。
  - 文件锁是由整个`Java`虚拟机持有的。
  - 在一些系统中，关闭一个通道会释放有`Java`虚拟机持有的底层文件上的所有锁。在一个锁定文件上避免使用多个通道。
  - 在网络文件系统上锁定文件是高度依赖于系统的，应该尽量避免。