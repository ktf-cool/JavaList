# 具体集合

## 一、链表

- 数组和数组列表删除一个元素开销很大，被删除元素之后的所有元素都要向数组的前端移动，插入一个元素也是。

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%B1%BB.png)

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0.png)

- 另一个数据结构——链表，将每个对象放在单独的链接中，每个链接中存放着序列中下一个元素的引用，在Java中，所有链表都是**双向链接**--即每个连接还存在着其前驱的引用。

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png)

- 丛链表中删除一个元素，只需跟新删除元素周围的连接即可。

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0.png)

> 链表是一个**有序集合**，每个对象的位置十分重要。`LinkedList.add`方法将对象添加到链表的尾部。但是需要将元素添加到链表的中间，这种依赖于位置的add方法将由迭代器负责，只有对自然有序的集合使用迭代器添加元素才有实际意义。

- 将链表中添加一个元素

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E5%B0%86%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%93%BE%E8%A1%A8%E4%B8%AD.png)

- 如果在某个迭代器修改集合时，另一个迭代器却在遍历这个集合，那么一定会出现混乱。链表迭代器设计为可以检测到这种修改，如果一个迭代器发现它的集合被另一个迭代器修改了，或是被集合自身的某个方法修改了，就会抛出一个异常。

> 为了避免发生并发修改异常，可以根据需要为一个集合关联多个迭代器，前提是这些迭代器只能读取集合。或者再关联一个能同时读写的迭代器。



## 二、数组列表

- List接口和实现了这个接口的LinkedList类，List接口用于描述一个有序集合，并且集合中的每个位置很重要，有两种访问元素的协议：一种是通过迭代器，另一种是通过get和set方法随机的访问每个元素。

> 需要动态数组时，可能会使用Vector类，但是为什么是使用ArrayList而不是Vector，因为Vector类的所有方法都是同步的。可以安全的从两个线程访问一个Vector对象，但是只从一个线程访问Vector,代码就会在同步代码块上浪费大量时间，而ArrayList方法是不同步的。



## 三、散列集

- 散列表：一种可以快速查找对象的数据结构，散列表为每个对象计算一个整数，称为**散列码**。散列码是由对象的实例字段得出的，不同的数据将产生不同的散列码。

> 如果定义你自己的类，就要负责实现自己的hashCode方法，你的实现与equals方法兼容，如果a.euqals(b)为true，a与b必须有相同的散列码。

- Java中，散列表用链表数组实现，每个列表被称为**桶**。想要查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，得到的结果就是保存这个元素的桶的索引。

> 如果桶中没有其他元素，将元素直接插入到桶中；如果桶已经被填充，这种现象被称为**散列冲突**，需要将新对象与桶中的对象进行比较，查看这个对象是否已经存在。

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E6%95%A3%E5%88%97%E8%A1%A8.png)

- 在Java8中，桶满时会从链表变成平衡二叉树。如果选择的散列函数不好，会产生很多冲突，或者如果有恶意代码试图在散列表中填充多个有相同散列码的值，这样改为平衡二叉树能提高性能。

> 如果想要更多的控制散列表的性能，可以指定一个初始桶数。桶数是指用于收集有相同散列值的桶的数目，如果插入到散列表中的元素太多，就会增加冲突量，降低检索性能。

- 通常，将桶数设置为预计元素个数的 75% ~ 150%，标准类库使用的桶数的2的幂，默认值是16。

> 如果最初元素的估计值过低，散列表就会太满，就需要**再散列**。填装因子可以确定何时对散列表进行再散列，如果填装因子为0.75(**默认值**)，说明表已经填满 75 % 以上，就会自动再散列，新表的桶数是原来的两倍。对于大多数程序来说，填装因子是0.75是合理的。



## 四、树集

-  TreeSet类与散列集十分类似，但是比散列表有所改进。树集是一个**有序集合**，可以以任意顺序将元素插入到集合中。在对集合进行遍历时，值将自动按照排序后的顺序呈现。

> 排序使用一个树数据结构完成的，当前使用的是红黑树。每次将一个元素添加到树中时，都会将其放置到正确的位置上，因此，迭代器总是以有序的顺序访问每个元素。

- 将一个元素添加到树中要比添加到散列表中慢，但是与检查数组或链表中的重复元素相比，使用树会快很多。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。（2是log的下标）

> 要使用树集，必须能够比较元素，这些元素必须实现Comparable接口，或者构造集时必须提供一个Comparable。如果想要具体的知道树集和散列集之间的差异，可以考虑收集一个矩形任务，树的排序必须是**全序**，任意两个元素都是可比的，并且只有在两个元素相等时结果才为0。



## 五、优先队列

- 优先队列中的元素可以按照任意的顺序插入，但会按照有序的顺序进行检索。

> 也就是说，无论何时调用remove方法，总会获得当前优先队列中的最小元素，但是优先队列并没有对所有元素进行排序，如果要迭代处理这些元素，并不需要对它们进行排序。

- 优先队列使用了一个精巧且高效的数据结构，成为**堆**（heap）。

> 堆是一个可以自组织的二叉树，其添加和删除操作可以让最小的元素移动到根，而不必花费时间对元素进行排序。

- 优先队列的典型用法是任务调度。

> 每一个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除。（remove操作会将最小的元素删除）
