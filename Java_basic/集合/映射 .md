# 映射 

## 一、基本映射操作

- 映射用来存放键值对。Java类库为映射提供了两个通用的实现：HashMap和TreeMap,这两个类都实现了Map接口。
- 散列映射对键进行散列，树映射根据键的顺序将元素组织为一个搜索树。散列或比较函数只应用于键，与键关联的值不进行散列或比较。

> 应该使用散列映射还是树映射呢？与集一样，散列稍微快一些，如果不需要按照有序的顺序访问键，最好使用散列映射。

- 每当往映射中添加一个对象时，必须同时提供一个键，想要检索一个对象，必须使用键。如果映射中没有存储与给定键对应的信息，get将返回null。

> 键必须是唯一的，不能对同一个键存放两个值。如果对同一个键调用两次put方法，第二次的值就会取代第一次的值，将返回与这个键关联的上一个值。

- 到迭代处理映射的键和值，最容易的就是使用forEach方法，可以提供一个接收键和值的lambda表达式。

```
scores.forEach((k,v) -> 
	System.out.println("key="+k+",value="+v);
)
```



## 二、更新映射条目

- 正常情况下，可以得到与一个键关联的原值，完成更新，再返回更新后的值。
- 当键第一次出现时，看下面这个例子：

```
counts.put(word, counts.get(word)+1);
```

> 当第一次看到word时，get会返回null，会抛出一个空指针异常。简单的补救是使用**getDefault**方法。

```java
counts.put(word, counts.getDefault(word,0)+1);
```

> 另一种补救方法是首先调用putIfAbset方法，只有当键原先存在时才会放入一个值。

```
counts.putIfAbsent(word,0);
counts.put(word, counts.get(word)+1);
```

> 还可以做的更好，merge方法可以简化这个操作，如果键原先不存在，下面的调用:将word与1关联，否者使用Integer::sum函数组合原值和1。

```
counts.merge(word, 1, Integer::sum);
```



## 三、映射视图

- 有三种视图：键集、值集合以及键值对集。键和键值对可以构成一个集，因为映射中一个键只能有一个副本。

```
Set<K> keySet()
Collection<V> values()
Set<Map,Entrty<K,V>> entrySet()
```

> 会分别返回三个视图，keySet不是HashSet或TreeSet,而是实现了Set接口的另外某个对象  。Set 接口扩展了Collection接口，因此可以像使用任何集合一样使用keySet。



## 四、链接散列集与映射

- `LinkedHashSet` 和 `LinkedHashMap`类会记住插入元素项的顺序，这样就可以避免散列表中的项看起来顺序是随机的，在表中插入元素时，就会并入到双向列表中。

![](D:\java笔记\Java脑图\连接散列表.png)

- 链接散列映射可以使用访问顺序而不是插入顺序来迭代处理映射条目。每次调用get或put时，收到影响的项将从当前的位置删除，并放到项链表的尾部。（只影响项在链表中的位置，而散列表的桶不会受影响，映射条目总是在键散列码对应的桶中。）要构造这样的一个散列映射，需要调用

```
LinkedHashMap<K,V>(initialCapacity,loadFactor,true)
```



## 五、枚举集与映射

- EnumSet 是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以EnumSet内部用位序列实现。如果对应的值在集中，则相应的位被置为1。

> EnumSet类没有公共的构造器，要使用静态工厂方法构造这个集。

- EnumMap是一个键类型为枚举类型的映射，它可以直接高效的实现为一个值数组。需要在构造器中指定键类型：

```
var personInCharge = new EnumMap<Weekday, Employee>(Weekday.class);
```



## 六、标识散列映射

- 类IndentityHashMap有特殊的用途，在这个类中，键的散列值不是用hashCode函数计算的，而是用System.identityHashCode方法计算的。这是Object.hashCode根据对象的内存地址计算散列码时所用的方法，而且在两个对象进行比较时，IdentityHashMap类使用==,而不使用equals。

> 也就是说，不同的键即使内容相同，也被视为不同对象。
