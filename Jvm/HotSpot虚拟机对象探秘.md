# 　`HotSpot`虚拟机对象探秘



## 一、对象的创建

- 在语言层面上，创建对象通常（例外：复制、反序列化）仅仅是一个`new`关键字，而在虚拟机中，对象（文
  中讨论的对象限于普通`Java`对象，不包括数组和`Class`对象等）的创建怎样的呢？

1. 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。
   1. 假设`Java`堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
   2. 如果`Java`堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。

- 仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，解决方案：
  - 对分配内存空间的动作进行同步处理——实际上虚拟机是采用`CAS`配上失败重试的方式保证更新操作的原子性；
  - 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在`Java`堆中预先分配一小块内存，称为本地线程分配缓冲。

- 内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，保证了对象的实例字段在`Java`代码中可以不赋初始值就直接使用。
- `Java`虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用`Object::hashCode()`方法时才计算）、对象的`GC`分代年龄等信息。这些信息存放在对象的对象头（`Object Header`）之中，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。





## 二、对象的内存布局

- 在`HotSpot`虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（`Header`）、实例数据（`Instance Data`）和对齐填充（`Padding`）。

- `HotSpot`虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码（`HashCode`）、`GC`分代年龄、锁状态标志、线程持有的锁、偏向线程`ID`、偏向时间戳等

- 对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。
  - 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。

- 实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。

- 对齐填充这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。



## 三、对象的访问定位。

- `Java`程序会通过栈上的`reference`数据来操作堆上的具体对象，对象访问方式也是由虚拟机实现而定的。

- 主流的访问方式主要有使用句柄和直接指针两种：

  - 如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，`reference`中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

  - 如果使用直接指针访问的话，`Java`堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，`reference`中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。

- 通过句柄访问对象：

![](D:\java笔记\JVM总结\image\通过句柄访问对象.png)

- 通过直接指针访问对象：

![](D:\java笔记\JVM总结\image\通过指针访问对象.png)