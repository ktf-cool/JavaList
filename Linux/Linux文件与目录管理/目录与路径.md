# 目录与路径

## 一、相对路径与绝对路径

- 绝对路径：路径的写法“一定由根目录 / 写起”，例如： `/usr/share/doc` 这个目录。
- 相对路径：路径的写法“不是由 / 写起”，例如由 /usr/share/doc 要到 /usr/share/man 下面
  时，可以写成： “cd ../man”这就是相对路径的写法啦！相对路径意指“相对于目前工作目
  录的路径！”

## 二、目录的相关操作

```java
. 代表此层目录
.. 代表上一层目录
- 代表前一个工作目录
~ 代表“目前使用者身份”所在的主文件夹
~account 代表 account 这个使用者的主文件夹（account是个帐号名称）
```

> 根目录的上一层（..）与根目录自己（.）是同一个目录。

- cd （change directory, 变换目录）

dmtsai这个使用者的主文件夹是`/home/dmtsai/`，而root主文件夹则是 `/ root/`，假设我以root身份在 Linux系统中

```jade
[dmtsai@study ~]$ su - # 先切换身份成为 root 看看！
[root@study ~]# cd [相对路径或绝对路径]
# 最重要的就是目录的绝对路径与相对路径，还有一些特殊目录的符号啰！
[root@study ~]# cd ~dmtsai
# 代表去到 dmtsai 这个使用者的主文件夹，亦即 /home/dmtsai
[root@study dmtsai]# cd ~
# 表示回到自己的主文件夹，亦即是 /root 这个目录
[root@study ~]# cd
# 没有加上任何路径，也还是代表回到自己主文件夹的意思喔！
[root@study ~]# cd ..
# 表示去到目前的上层目录，亦即是 /root 的上层目录的意思；
[root@study /]# cd -
# 表示回到刚刚的那个目录，也就是 /root 啰～
[root@study ~]# cd /var/spool/mail
# 这个就是绝对路径的写法！直接指定要去的完整路径名称！
[root@study mail]# cd ../postfix
# 这个是相对路径的写法，我们由/var/spool/mail 去到/var/spool/postfix 就这样写！
```

> 目录名称与cd指令之间存在一个空格。

- pwd （显示目前所在的目录）

```
[root@study ~]# pwd [-P]
选项与参数：
-P ：显示出确实的路径，而非使用链接 （link） 路径。
范例：单纯显示出目前的工作目录：
[root@study ~]# pwd
/root &lt;== 显示出目录啦～
范例：显示出实际的工作目录，而非链接文件本身的目录名而已
[root@study ~]# cd /var/mail &lt;==注意，/var/mail是一个链接文件
[root@study mail]# pwd
/var/mail &lt;==列出目前的工作目录
[root@study mail]# pwd -P
/var/spool/mail &lt;==怎么回事？有没有加 -P 差很多～
[root@study mail]# ls -ld /var/mail
lrwxrwxrwx. 1 root root 10 May 4 17:51 /var/mail -&gt; spool/mail
# 看到这里应该知道为啥了吧？因为 /var/mail 是链接文件，链接到 /var/spool/mail
# 所以，加上 pwd -P 的选项后，会不以链接文件的数据显示，而是显示正确的完整路径啊！
```

- mkdir （创建新目录）

```
[root@study ~]# mkdir [-mp] 目录名称
选项与参数：
-m ：设置文件的权限喔！直接设置，不需要看默认权限 （umask） 的脸色～
-p ：帮助你直接将所需要的目录（包含上层目录）递回创建起来！
范例：请到/tmp下面尝试创建数个新目录看看：
[root@study ~]# cd /tmp
[root@study tmp]# mkdir test &lt;==创建一名为 test 的新目录
[root@study tmp]# mkdir test1/test2/test3/test4
mkdir: cannot create directory ‘test1/test2/test3/test4’: No such file or directory
# 话说，系统告诉我们，没可能创建这个目录啊！就是没有目录才要创建的！见鬼嘛？
[root@study tmp]# mkdir -p test1/test2/test3/test4
# 原来是要建 test4 上层没先建 test3 之故！加了这个 -p 的选项，可以自行帮你创建多层目录！
范例：创建权限为rwx--x--x的目录
[root@study tmp]# mkdir -m 711 test2
[root@study tmp]# ls -ld test*
drwxr-xr-x. 2 root root 6 Jun 4 19:03 test
drwxr-xr-x. 3 root root 18 Jun 4 19:04 test1
drwx--x--x. 2 root root 6 Jun 4 19:05 test2
# 仔细看上面的权限部分，如果没有加上 -m 来强制设置属性，系统会使用默认属性。
# 那么你的默认属性为何？这要通过下面介绍的 [umask](../Text/index.html#umask) 才能了解喔！ ^_^
```

- rmdir （删除“空”的目录）

```
[root@study ~]# rmdir [-p] 目录名称
选项与参数：
-p ：连同“上层”“空的”目录也一起删除
范例：将于mkdir范例中创建的目录（/tmp下面）删除掉！
[root@study tmp]# ls -ld test* &lt;==看看有多少目录存在？
drwxr-xr-x. 2 root root 6 Jun 4 19:03 test
drwxr-xr-x. 3 root root 18 Jun 4 19:04 test1
drwx--x--x. 2 root root 6 Jun 4 19:05 test2
[root@study tmp]# rmdir test &lt;==可直接删除掉，没问题
[root@study tmp]# rmdir test1 &lt;==因为尚有内容，所以无法删除！
rmdir: failed to remove ‘test1’: Directory not empty
[root@study tmp]# rmdir -p test1/test2/test3/test4
[root@study tmp]# ls -ld test* &lt;==您看看，下面的输出中test与test1不见了！
drwx--x--x. 2 root root 6 Jun 4 19:05 test2
# 瞧！利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除～
# 不过要注意的是，这个 rmdir 仅能“删除空的目录”喔！
```

## 三、关于可执行文件路径的变量：$PATH

- 查阅文件属性的指令ls完整文件名为：/bin/ls 。为什么可以在任何地方执行/bin/ls这个指令呢？这是因为环境变量 PATH 的帮助所致呀！例如：，系统会依照PATH的设置去每个PATH定义的目录下搜寻文件名为ls的可执行文件， 如果在PATH定义的目录中含有多个文件名为ls的可可执行文件，那么先搜寻到的同名指令先被执行！

```
[root@study ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
范例：用dmtsai的身份列出搜寻的路径为何？
[root@study ~]# exit # 由之前的 su - 离开，变回原本的帐号！或再取得一个终端机皆可！
[dmtsai@study ~]$ echo $PATH
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
# 记不记得我们前一章说过，目前 /bin 是链接到 /usr/bin 当中的喔！
```

```
[root@study ~]# mv /bin/ls /root
# mv 为移动，可将文件在不同的目录间进行移动作业
```

- 如果想要让root在任何目录均可执行/root下面的ls，那么就将/root加入PATH当中即可。

```
[root@study ~]# PATH="${PATH}:/root"
```

> 不同身份使用者默认的PATH不同，默认能够随意执行的指令也不同（如root与dmtsai）；
> PATH是可以修改的；
> 使用绝对路径或相对路径直接指定某个指令的文件名来执行，会比搜寻PATH来的正确；
> 指令应该要放置到正确的目录下，执行才会比较方便；
> 本目录（.）最好不要放到PATH当中。
