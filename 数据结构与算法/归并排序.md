# 归并排序



## 一、原地归并的抽象方法

- 归并排序：要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。

- 原地归并：可以先将前半部分排序，再将后半部分排序，然后移动元素而不需要使用额外的空间。
- 与之对应的方法签名`merge(a, lo, mid, hi)`,它会将子数组`a[lo..mid]`和`a[mid+1..hi]`归并成一个有序的数组并将结果存放在`a[lo..hi]`中，如下代码：

```java
public static void merge(Comparable[] a, int lo, int mid, int hi) {
	//将a[lo..mi] 和 a[min+1..hi]归并
	int i = lo, j = mid + 1;
	for(int k = lo; k <= hi; k++) {  //将a[lo..hi]复制到aux[lo..hi]
		aux[k] = a[k]; 
	}
	for(int k = lo; k <= hi; k++) {
		if(i > mid) 
			a[k] = aux[j++];
		else if(j > hi) 
			a[k] = aux[i++];
		else if(less(aux[j], aux[i]))
			a[k] = aux[j++];
		else
			a[k] = aux[i++];
	}
}
```

> 该方法先将所有元素复制到aux[ ] 中，然后再归并回a[ ] 中。方法在归并时（第二个for循环）进行了4个条件判断：左半边用尽（取右半边的元素）、右半边用尽（取左半边的元素）、右半边的当前元素小于左半边的当前元素（取右半边的元素）以及右半边的当前元素大于等于左半边的当前元素（取左半边的元素）。



## 二、自顶向下的归并排序

- 自顶向下的归并排序：

```java
public class Merge {
	private static Comparable[] aux;   //归并所需的辅助数组
	private static void sort(Comparable[] a) {
		aux = new Comparable[a.length];  //一次性分配空间
		sort(a, 0, a.length - 1);
	}
	private static void sort(Comparable[] a, int lo, int hi) {
		//将数组a[lo..hi]排序
		if(hi <= lo) 
			return ;
		int mid = lo + (hi - lo)/2;
		sort(a, lo, mid);  //将左半边排序
		sort(a, mid + 1, hi);   //将右半边排序
		merge(a, lo, mid, hi);  //归并结束
	}
}
```



## 三、自底向上的归并排序

- 自底向上的归并排序：

```java
public class MergeBU {
	private static Comparable[] aux;  //归并所需的辅助数组
	public static void sort(Comparable[] a) {
		//进行lgN次排序
		int N = a.length;
		aux = new Comparable[N];
		for(int lo = 0; lo < N - sz; lo +=sz + sz)
        	merge(a, lo, lo + sz - 1, Math.min(lo + sz+sz-1, N-1));
	}
}
```

