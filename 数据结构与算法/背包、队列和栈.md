# 背包、队列和栈



## 一、背包

-  背包是一种不支持从中删除元素的集合数据类型，目的是帮助用例收集元素并迭代遍历所有收集到的元素。

- 用例可以检查背包是否为空或者获取背包中元素的数量。

- 迭代的顺序不确定且与用例无关。
- 使用`Bag`的`API`，用例可以将元素添加进背包并根据需要随时使用`foreach`语句访问所有的元素。（用例可以是栈或者队列）
- 背包的`API`:

| 背包                                               |                  |
| -------------------------------------------------- | ---------------- |
| `public class Bag<Item> implements Iterable<Item>` |                  |
| `Bag( )`                                           | 创建一个空背包   |
| `void add(Item item)`                              | 添加一个元素     |
| `boolean isEmpty ()`                               | 背包是否为空     |
| `int size( )`                                      | 背包中的元素数量 |

- 下面Stats类是Bag的一个典型用例，简单地计算标准输入中的所有double值的平均值和样本标准差：

```java
public class Stats {
	public static void main(String[] args) {
		Bag<Double> numbers = new Bag<Double>();
		while(!StdIn.isEmpty()) 
			numbers.add(StdIn.readDouble());
		int N = numbers.size();
		double sum = 0.0;
		for(double x : numbers)
			sum += x;
		double mean = sum/N;
		sum = 0.0;
		for(double s : numbers)
			sum += (x - mean) * (x - mean);
		double std = Math.sqrt(sum/(N - 1));
		StdOut.printf("Mean: %.2f\n", mean);
		StdOut.printf("Std dev: %.2f\n", std);
	}
}
```



## 二、先进先出队列

- 先进先出队列（或者简称队列）是一种基于先进先出策略的集合类型。

- 当用例使用`foreach`语句迭代访问队列中的元素时，元素的处理顺序就是它们被添加到队列中的顺序。
- 在应用程序中使用队列的主要原因是在用集合保存元素的同时保存它们的相对顺序：使它们入列顺序和出列顺序相同。
- 队列的`API`：

| 先进先出(`FiFO`)队列                                 |                    |
| ---------------------------------------------------- | ------------------ |
| `public class Queue<Item> implements Iterable<Item>` |                    |
| `Queue( )`                                           | 创建空队列         |
| `void enqueue(Item item)`                            | 添加一个元素       |
| Item dequeue( )                                      | 删除最近添加的元素 |
| `boolean isEmpty( )`                                 | 队列是否为空       |
| `int size( )`                                        | 队列中的元素数量   |

- 一个典型的先进先出队列：

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%98%9F%E5%88%97.png)

- Queue的用例：

```java
public static int[] readInts(String name) {
	In in = new In(name);
	Queue<Integer> q = new Queue<Integer>();
	while(!in.isEmpty()) 
		q.enqueue(in.readInt());
	int N = q.size();
	int[] a = new int[N];
	for(int i = 0; i < N; i++) {
		a[i] = q.dequeue();
	}
	return a;
}
```



## 三、下压栈

- 下压栈（或简称栈）是一种基于后进先出（`LIFO`）策略的集合类型。

- 当用例使用`foreach`语句迭代遍历栈中的元素时，元素的处理顺序和它们被压入的顺序正好相反。
- 在应用程序中使用栈迭代器的一个典型原因是在用集合保存元素的同时颠倒它们的相对顺序。
- 栈的`API`：

| 下压（后进先出，LIFO）栈                             |                    |
| ---------------------------------------------------- | ------------------ |
| `public class Stack<Item> implements Iterable<Item>` |                    |
| `Stack( )`                                           | 创建一个空栈       |
| `void push(Item item)`                               | 添加一个元素       |
| `Item pop()`                                         | 删除最近添加的元素 |
| `boolean isEmpty( )`                                 | 栈是否为空         |
| `int size( )`                                        | 栈中的元素数量     |

- 下压栈操作：

![image]([https://github.com/ktf-cool/JavaList/blob/master/images/%E4%B8%8B%E5%8E%8B%E6%A0%88%E6%93%8D%E4%BD%9C.png)

- 栈的用例：

```java
public class Reverse {
	public static void main(String[] args) {
		Stack<Integer> stack;
		stack = new Stack<Integer>();
		while(!StdIn.isEmpty)
			stack.push(StdIn.readInt());
		for(int i : stack)
			StdOut.println(i);
	}
}
```

