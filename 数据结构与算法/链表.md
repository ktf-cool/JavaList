# 链表



## 一、节点记录

- **链表**：是一种递归的数据结构，它或者为空（`null`），或者是指向一个结点（`node`）的引用，该节点含有一个泛型元素和一个指向另一条链表的引用。

- 结点是一个可能含有任意类型数据的抽象实体，它所包含的指向结点的应用显示了它在构造链表之中的作用。
- 用嵌套类来定义结点的抽象数据类型：

```java
private class Node {
	Item item;
	Node next;
}
```

> 1. 一个`Node`对象含有两个实例变量，类型分别为`Item`(参数类型) 和 `Node` 。
> 2. 在需要使用`Node`类的类中定义它并将它标记为`private`。

- 通过 `new Node( )` 触发（无参数的）构造函数来创建一个`Node`类型的对象。
  - 调用的结果是一个指向`Node`对象的引用，它的实例变量均被初始化为`null` 。
  - `Item`是一个占位符，表示用链表处理的任意数据类型。



## 二、构造链表

- 只需要一个`Node`类型的变量就能表示一条链表，只要保证它的值是`null`或者指向另一个`Node`对象且该对象的`next`域指向了另一条链表即可。

- 例如构造一条含有元素`to`、`be` 和 `or` 的链表:

1. 首先为每个元素创建一个结点：

```java
Node first = new Node();
Node second = new Node();
Node third = new Node();
```

2. 将每个结点的`item`域设为所需的值：（假设本例中`Item`为`String`）

```java
first.item = "to";
second.item = "be";
third.item = "or";
```

3. 设置`next`域来构造链表：

```java
first.next = second;
second.next = third;
```

> `third.next`仍然是`null`，即创建时被初始化的值）。

- 构造如图所示：

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%9E%84%E9%80%A0%E4%B8%80%E6%9D%A1%E9%93%BE%E8%A1%A8.png)



## 三、在表头插入结点

- 例如：要在首节点为`first`的给定链表开头插入字符串`not`,先将`first`保存在`oldfirst`中，然后将一个新节点赋予`first`，并将它的`item`域设为`not`，`next`域设为`oldfirst`.

- 如图：

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BC%80%E5%A4%B4%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%B0%E7%BB%93%E7%82%B9.png)



## 四、从表头删除结点

- 只需将`first`指向`first.next`即可。一旦改变了`first`的值。就再也无法访问它曾经指向的结点了，曾经的结点对象变成孤儿，`Java`的内存管理系统最终将回收它所占用的内存。

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E9%A6%96%E7%BB%93%E7%82%B9.png)



## 五、在表尾插入结点

- 需要一个指向链表最后一个结点的连接，因为该结点的连接必须被修改并指向一个含有新元素的新结点。

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E5%B0%BE%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%B0%E7%BB%93%E7%82%B9.png)



## 六、其他位置的插入和删除操作

- 实现任意插入和删除操作的标准解决方案是使用双向链表，其中每个结点都含有两个链接，分别执行不同的方向。



## 七、遍历

- 要访问一个数组中的所有元素，使用如下代码处理`a[ ]` 中的所有元素：

```java
for (int i = 0; i < N; i++) {
	// 处理 a[i]
}
```

- 访问链表中所有元素的方式：将循环的索引变量`x`初始化为链表的首结点，然后通过`x.item`访问和`x`相关联的元素，并将`x`设为`x.next`来访问链表中的下一个结点，如此反复直到`x`为`null`为止，这个过程称为链表的遍历。代码如下：

```java
for (Node x = first; x != null; x = x.next) {
	// 处理 x.item
}
```



## 八、栈的实现

- 将栈保存为一条链表，栈的顶部即为表头，实例变量`first`指向栈顶。

- 1. 当使用`push( )` 压入一个元素时，将元素添加在表头。
  2. 当使用`pop( )` 删除一个元素时，将元素从表头删除。
  3. 要实现`size( )` 方法，用实例变量`N`保存元素的 个数，在压入元素时将`N`加`1`，在弹出元素时将`N`减`1`。
  4. 要实现 `isEmpty( )` 方法，只需检查`first`是否为`null`（或者可以检查`N`是否为`0`）。

- 链表的使用达到了最优设计目标：
  - 它可以处理任意类型的数据。
  - 所需的空间总是和集合的大小成正比。
  - 操作所需的时间总是和集合的大小无关。

- `stack`的开发用例的轨迹：

![image](https://github.com/ktf-cool/JavaList/blob/master/images/stack%E7%9A%84%E5%BC%80%E5%8F%91%E7%94%A8%E4%BE%8B%E8%BD%A8%E8%BF%B9.png)

- `Stack`的测试用例：

```java
public static void main(String[] args) {
	//创建一个栈并根据StdIn中的指示压入或弹出字符串
	Stack<String> s = new Stack<String>();
	while(!StdIn.isEmpty())r {
		String item = StdIn.readString();
		if(!item.equals("-"))
			s.push(item);
		else if (!s.isEmpty()) 
			StdOut.print(s.pop() + " ");
	}
	StdOut.println("(" + s.size() + "left on stack)");
}
```

- 下压堆栈（链表实现）

```java
public class Stack<Item> implements Iterable<Item> {
	private Node first; //栈顶（最近添加的元素）
	private int N;
	private class Node {
		//定义了结点的嵌套类
		Item item;
		Node next;
	}
	public boolean isEmpty() {
		return first = null;  // 或：N == 0
	}
	public int size() {
		return N;
	}
	public void push(Item item) {
		//向栈顶添加元素
		Node oldfirst = first;
		first = new Node();
		first.item = item;
		first.next = oldfirst;
		N++;
	}
	public Item pop() {
		//从栈顶删除元素
		Item item = first.item;
		first = first.next;
		N--;
		return item;
	}
	//iterable()的实现请见算法1.4
	测试用例main()的实现请见本节前面部分
}
```



## 九、队列的实现

- 将队列表示为一条从最早插入的元素到最近插入的元素的链表，实例变量`first`指向队列的开头，实例变量`last`指向队列的结尾。
  - 将一个元素入列（`enqueue`( ) ) , 就将它添加到表尾（但是链表为空时需要将`first`和`last`都指向新结点）。
  - 要将一个元素出列（ `dequeue`( ) ），就删除表头的结点（当链表为空时需要更新`last`的值）。

- `Queue`的实现使用的数据结构和`Stack`相同--链表，但是实现了不同的添加和删除元素的算法。（这也是后进先出和先进后出的区别）
- `Queue`的测试用例：

```java
public static void main(String[] args) {
	// 创建一个队列并操作字符串入列或出列
	Queue<String> q = new Queue<String>();
	while(!StdIn.isEmpty()) {
		String item = StdIn.readString();
		if(!item.equals("-"))
			q.enqueue(item);
		else if(!q.isEmpty()) 
			StdOut.print(q.dequeue()) + " ");
	}
	StdOut.println("(" + q.size() + " left on queue)"); 
}
```

- 先进先出队列：

```java
public class Queue<Item> implements Iterable<Item> {
	private Node first;  //指向最早添加的结点的链接
	private Node last;  //执行最近添加结点的链接
	private in N;      //队列中的元素数量
	private class Node {
		//定义了结点的嵌套类
		Item item;
		Node next;
	}
	public boolean isEmpty() {
		return first == null;   //或： N == 0;
	}
	public int size() {
		return N;
	}
	public void enqueue(Item item) {
		//向表尾添加元素
		Node oldlast = last;
		last = new Node();
		last.item = item;
		last.next = null;
		if(isEmpty()) 
			first = last;
		else
			oldlast.next = last;
        N++;
	} 
	public Item dequeue() {
		//从表头删除元素
		Item item = first.item;
		first = first.next;
		if(isEmpty())
			last = null;
		N--;
		return item;
	}
}
```

- Queue的开发用例的轨迹：

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E9%98%9F%E5%88%97%E7%9A%84%E5%BC%80%E5%8F%91%E7%94%A8%E4%BE%8B%E8%BD%A8%E8%BF%B9.png)



## 十、背包的实现

- 用链表数据结构实现`Bag API`只需将`Stack`中的`push( )` 改名为 `add( )`,并去掉`pop( )`的实现即可。

- Bag 是后进先出的顺序。

```java
public class Bag<Item> implements Iterable<Item> {
	private Node first;  //链表的首结点
	private class Node {
		Item item;
		Node next;
	}
	public void add(Item item) {
		// 和Stack的push()方法完全相同
		Node oldfirst = first;
		first = new Node();
		first.item = item;
		first.next = oldfirst;
	}
    public Iterator<Item> iterator() {
        return new ListInterator();
    }
    private class ListIterator implements Iterable<Item> {
        private Node current = first;
        public boolean hasNext() {
            return current != null;
        }
        public void remove(){
            
        }
        public Item next(){
            Item item = current.item;
            current  = current.next;
            return item;
        }
    }
}
```

- 基础数据结构：

| 数据结构 | 优点                           | 缺点                           |
| -------- | ------------------------------ | ------------------------------ |
| 数组     | 通过索引可以直接访问任何元素   | 在初始化时就需要知道元素的数量 |
| 链表     | 使用的空间大小和元素数量成正比 | 需要通过引用访问任意元素       |

