# 输出流与输入流



## 一、输出流

- `Java`的基本输出流类是 `java.io.OutputStream`:

```java
public abstract class OutputStream
```

- 这个类提供了写入数据所需的基本 方法：

```java
public abstract void write(int b) throws IOException  0-255整数作为参数
public void write(byte[] data) throws IOException
public void write(byte[] data, int offset, int length) throws IOException
public void flush() throws IOException
public void close() throws IOException
```

> `OutputStream`的子类使用这些方法向某种特定介质写入数据。

- `write`方法接受一个`int`作为参数，但是实际上会写入一个无符号字节。

> `Java`没有无符号字节，所以要用`int` 来代替。

- 一次写入1字节通常效率不高。
  - 例如：流出以太网卡的每个TCP分片包含至少40字节的开销用于路由和纠错。如果每次都单字节发送，实际填入网络中的数据可能比比预想的数据量相比要高出41倍以上，还不算主机网络层协议的开销。
- 因此大多数`TCP/IP`实现都会在某种程度上缓存数据。
  - 它们在内存中积累数据字节，只有积累到一定量的数据后，或者经过了一定时间后，才将所积累的数据发送到最终目的地。
- 使用`write(byte[ ] data)` 或 `write(byte[ ] data, int offset, int length)` 通常比一次写入`data`数组中的1字节快得多。

- `flush( )` 方法可以强迫缓冲的流发送数据，即使缓冲区还没有满，打破服务器与客户端之间的一种死锁状态。

![image](https://github.com/ktf-cool/JavaList/blob/master/images/%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1.png)

- 当结束一个流的操作时，通常要调用它的`close( )` 方法将其关闭。

> 这会释放与这个流关联的所有资源，如文件句柄或端口。如果流来自一个网络连接，那么关闭这个流也会终止这个连接。

- 一旦输出流关闭，继续写入时就会抛出`IOException`异常。
  - 有些流仍允许对这个对象做一些处理。
- 在一个长时间运行的程序中，如果未能关闭一个流，则可能会泄露文件句柄、网络端口和其他资源。
  - 做法是使用一个`finally`块中关闭流。（`Java6`及以前）

```java
OutputStream out = null;
try {
	out = new FileOutputStream("/tmp/data.txt");
	//处理输出流...
} catch (IOException ex) {
	System.err.println(ex.getMessage());
} finally {
	if (out != null) {
		try {
			out.close();
		} catch (IOException ex) {
			//忽略
		}
	}
}
```

> 这种技术有时称为释放模式，对于需要在垃圾回收前进行清理的对象是很常见的。

- `Java7`引入了“带资源的try” 构造（`try with resources`), 可以更简洁的完成这个清理。

```java
try(OutputStream out = new FileOutputStream("/tmp/data.txt")) {
	//处理输出流
} catch (IOException ex) {
	System.err.println(ex.getMessage());
}
```

> Java会对try块参数表中声明的所有`AutoCloseable`对象自动调用`close( )` 。



## 二、输入流

- `Java`的基本输入类是`java.io.InputSteam`:

```java
public abstract class InputStream
```

- 这个类提供了将数据读取为原始字节所需的基本方法：

```java
public abstract int read() throws IOException
public int read(byte[] input) throws IOException
public int read(byte[] input, int offset, int length) throwa IOException
public long skip(long n) throws IOException
public int available() throws IOException
public void close() throws IOException
```

> `InputStream`的具体子类使用这些方法从某种特定介质中读取数据。

- `InputSteam`的基本方法是没有参数的`read( )` 方法。
  - 这个方法从输入流的源中读取1字节数据，作为一个0到255的`int`返回。
  - 流的结束通过-1来表示。
  - `read( )` 方法会等待并阻塞其后任何代码的执行，直到有1字节的数据可供读取。

- 有两个重载的`read( )` 方法，可以用从流中读取的多字节数据填充一个指定数组：`read(byte[] input)` 和 `read(byte[ ] input, int offset, int length)`。
  - 第一个方法尝试填充指定的数组`input`。
  - 第二个方法尝试填充指定的`input`中`offset`开始连续`length`字节的子数组。

- 如果不想等待所需的全部字节都立即可用，可以使用`avaiable( )` 方法来确定不阻塞的情况下有多少字节可以读取

- 在少数情况下，可能希望跳过数据不进行读取。`skip( )` 方法可以完成任务。

- 一旦结束对输入流的操作，应当调用它的close( ) 方法将其关闭，这会释放与这个流关联的所有资源，如句柄或端口。



## 三、标记和重置

- `InputStream`类有3个不非常的方法，允许程序备份和重新读取已经读取的数据：

```java
public void mark(int readAheadLimit)
public void reset() throws IOException
public boolean markSupported()
```

- 为了重新读取数据，要用mark( ) 方法标记流的当前位置。在以后某个时刻，可以调用reset( ) 方法把流重置到之前标记的位置。
  - 接下来的读取操作会返回从标记位置开始的数据，但不能重置任意远的位置，否则会抛出`IOException`异常。
  - 一个流在任意时刻都只能有一个标记，标记第二个位置会清除第一个标记。
