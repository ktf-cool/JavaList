# `Java`并发机制的应用



## 一、`volatile`的应用

- `Java`编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。
- `Java`语言提供了`volatile`，在某些情况下比锁要更加方便。
  - 如果一个字段被声明成`volatile`，`Java`线程内存模型确保所有线程看到这个变量的值是一致的。

> `volatile`是轻量级的`synchronized`，它在多处理器开发中保证了共享变量的“可见性”。
>
> 可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。
>
> 如果`volatile`变量修饰符使用恰当的话，它比`synchronized`的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。



## 二、`synchronized`的应用

- `synchronized`实现同步的基础：`Java`中的每一个对象都可以作为锁。具体表现为以下3种形式：
  1. 对于普通同步方法，锁是当前实例对象。
  2. 对于静态同步方法，锁是当前类的Class对象。
  3. 对于同步方法块，锁是`Synchonized`括号里配置的对象。

- 当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。

- 在`Java SE 1.6`中，锁一共有`4`种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。

  > 锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。

  ### 1.偏向锁

- 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程`ID`，以后该线程在进入和退出同步块时不需要进行`CAS`操作来加锁和解锁，只需简单地测试一下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。
  1. 如果测试成功，表示线程已经获得了锁。
  2. 如果测试失败，则需要再测试一下`Mark Word`中偏向锁的标识是否设置成`1`（表示当前是偏向锁）：
  3. 如果没有设置，则使用`CAS`竞争锁；如果设置了，则尝试使用`CAS`将对象头的偏向锁指向当前线程。

- 偏向锁的获得和撤退流程：

![](D:\java笔记\并发总结\images\偏向锁的获得和撤退流程.png)

- 偏向锁在`Java 6`和`Java 7`里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用`JVM`参数来关闭延迟：`-XX:BiasedLockingStartupDelay=0`。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过`JVM`参数关闭偏向锁：`-XX:-UseBiasedLocking=false`，那么程序默认会进入轻量级锁状态。

### 2.轻量级锁

- 轻量级锁加锁：线程在执行同步块之前，`JVM`会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的`Mark Word`复制到锁记录中，官方称为`Displaced Mark Word`。然后线程尝试使用`CAS`将对象头中的`Mark Word`替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

- 轻量级锁解锁：轻量级解锁时，会使用原子的`CAS`操作将`Displaced Mark Word`替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。

![](D:\java笔记\并发总结\images\轻量级锁级膨胀流程图.png)

> 因为自旋会消耗`CPU`，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

- 锁的优缺点对比:

![](D:\java笔记\并发总结\images\锁的优缺点对比.png)